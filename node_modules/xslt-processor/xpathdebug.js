"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toString = exports.parseTree = void 0;
// Copyright 2023-2024 Design Liquido
// Copyright 2018 Johannes Wilm
// Copyright 2005 Google Inc.
// All Rights Reserved
//
// Debug stuff for the XPath parser. Also used by XSLT.
var dom_1 = require("./dom");
var xpath_1 = require("./xpath");
var expressions_1 = require("./xpath/expressions");
var node_tests_1 = require("./xpath/node-tests");
var values_1 = require("./xpath/values");
var parseTree = function (expr, indent) {
    var ret;
    switch (expr.constructor) {
        case expressions_1.TokenExpr:
            ret = "".concat(indent, "[token] ").concat(expr.value, "\n");
            break;
        case expressions_1.LocationExpr:
            ret = "".concat(indent, "[location] ").concat(expr.absolute ? 'absolute' : 'relative', "\n");
            for (var i = 0; i < expr.steps.length; ++i) {
                ret += (0, exports.parseTree)(expr.steps[i], "".concat(indent, " "));
            }
            break;
        case expressions_1.StepExpr:
            ret = "".concat(indent, "[step]\n").concat(indent, " [axis] ").concat(expr.axis, "\n").concat((0, exports.parseTree)(expr.nodeTest, "".concat(indent, " ")));
            for (var i = 0; i < expr.predicate.length; ++i) {
                ret += (0, exports.parseTree)(expr.predicate[i], "".concat(indent, " "));
            }
            break;
        case node_tests_1.NodeTestAny:
        case node_tests_1.NodeTestElementOrAttribute:
        case node_tests_1.NodeTestText:
        case node_tests_1.NodeTestComment:
        case node_tests_1.NodeTestPI:
        case node_tests_1.NodeTestName:
        case node_tests_1.NodeTestNC:
            ret = "".concat(indent, "[nodeTest] ").concat((0, exports.toString)(expr), "\n");
            break;
        case expressions_1.PredicateExpr:
            ret = "".concat(indent, "[predicate]\n").concat((0, exports.parseTree)(expr.expr, "".concat(indent, " ")));
            break;
        case expressions_1.FunctionCallExpr:
            ret = "".concat(indent, "[function call] ").concat(expr.name.value, "\n");
            for (var i = 0; i < expr.args.length; ++i) {
                ret += (0, exports.parseTree)(expr.args[i], "".concat(indent, " "));
            }
            break;
        case expressions_1.UnionExpr:
            ret = "".concat(indent, "[union]\n").concat((0, exports.parseTree)(expr.expr1, indent + ' ')).concat((0, exports.parseTree)(expr.expr2, "".concat(indent, " ")));
            break;
        case expressions_1.PathExpr:
            ret = "".concat(indent, "[path]\n").concat(indent, "- filter:\n").concat((0, exports.parseTree)(expr.filter, "".concat(indent, " "))).concat(indent, "- location path:\n").concat((0, exports.parseTree)(expr.rel, "".concat(indent, " ")));
            break;
        case expressions_1.FilterExpr:
            ret = "".concat(indent, "[filter]\n").concat(indent, "- expr:\n").concat((0, exports.parseTree)(expr.expr, "".concat(indent, " ")));
            "".concat(indent, "- predicates:\n");
            for (var i = 0; i < expr.predicate.length; ++i) {
                ret += (0, exports.parseTree)(expr.predicate[i], "".concat(indent, " "));
            }
            break;
        case expressions_1.UnaryMinusExpr:
            ret = "".concat(indent, "[unary] -\n").concat((0, exports.parseTree)(expr.expr, "".concat(indent, " ")));
            break;
        case expressions_1.BinaryExpr:
            ret = "".concat(indent, "[binary] ").concat(expr.op.value, "\n").concat((0, exports.parseTree)(expr.expr1, "".concat(indent, " "))).concat((0, exports.parseTree)(expr.expr2, "".concat(indent, " ")));
            break;
        case expressions_1.LiteralExpr:
            ret = "".concat(indent, "[literal] ").concat((0, exports.toString)(expr), "\n");
            break;
        case expressions_1.NumberExpr:
            ret = "".concat(indent, "[number] ").concat((0, exports.toString)(expr), "\n");
            break;
        case expressions_1.VariableExpr:
            ret = "".concat(indent, "[variable] ").concat((0, exports.toString)(expr), "\n");
            break;
        case values_1.StringValue:
        case values_1.NumberValue:
        case values_1.BooleanValue:
        case values_1.NodeSetValue:
            ret = "".concat(expr.type, ": ").concat(expr.value);
            break;
        default:
            break;
    }
    return ret;
};
exports.parseTree = parseTree;
var toString = function (expr) {
    var ret;
    switch (expr.constructor) {
        case expressions_1.FunctionCallExpr:
            ret = "".concat(expr.name.value, "(");
            for (var i = 0; i < expr.args.length; ++i) {
                if (i > 0) {
                    ret += ', ';
                }
                ret += (0, exports.toString)(expr.args[i]);
            }
            ret += ')';
            break;
        case expressions_1.UnionExpr:
            ret = "".concat((0, exports.toString)(expr.expr1), " | ").concat((0, exports.toString)(expr.expr2));
            break;
        case expressions_1.PathExpr:
            ret = "{path: {".concat((0, exports.toString)(expr.filter), "} {").concat((0, exports.toString)(expr.rel), "}}");
            break;
        case expressions_1.FilterExpr:
            ret = (0, exports.toString)(expr.expr);
            for (var i = 0; i < expr.predicate.length; ++i) {
                ret += (0, exports.toString)(expr.predicate[i]);
            }
            break;
        case expressions_1.UnaryMinusExpr:
            ret = "-".concat((0, exports.toString)(expr.expr));
            break;
        case expressions_1.BinaryExpr:
            ret = "".concat((0, exports.toString)(expr.expr1), " ").concat(expr.op.value, " ").concat((0, exports.toString)(expr.expr2));
            break;
        case expressions_1.LiteralExpr:
            ret = "\"".concat(expr.value, "\"");
            break;
        case expressions_1.NumberExpr:
            ret = "".concat(expr.value);
            break;
        case expressions_1.VariableExpr:
            ret = "$".concat(expr.name);
            break;
        case dom_1.XNode:
            ret = expr.nodeName;
            break;
        case xpath_1.ExprContext:
            ret = "[".concat(expr.position, "/").concat(expr.nodeList.length, "] ").concat(expr.node.nodeName);
            break;
        case expressions_1.TokenExpr:
            ret = expr.value;
            break;
        case expressions_1.LocationExpr:
            ret = '';
            if (expr.absolute) {
                ret += '/';
            }
            for (var i = 0; i < expr.steps.length; ++i) {
                if (i > 0) {
                    ret += '/';
                }
                ret += (0, exports.toString)(expr.steps[i]);
            }
            break;
        case expressions_1.StepExpr:
            ret = "".concat(expr.axis, "::").concat((0, exports.toString)(expr.nodeTest));
            for (var i = 0; i < expr.predicate.length; ++i) {
                ret += (0, exports.toString)(expr.predicate[i]);
            }
            break;
        case node_tests_1.NodeTestAny:
            ret = 'node()';
            break;
        case node_tests_1.NodeTestElementOrAttribute:
            ret = '*';
            break;
        case node_tests_1.NodeTestText:
            ret = 'text()';
            break;
        case node_tests_1.NodeTestComment:
            ret = 'comment()';
            break;
        case node_tests_1.NodeTestPI:
            ret = 'processing-instruction()';
            break;
        case node_tests_1.NodeTestNC:
            ret = "".concat(expr.nsprefix, ":*");
            break;
        case node_tests_1.NodeTestName:
            ret = expr.name;
            break;
        case expressions_1.PredicateExpr:
            ret = "[".concat((0, exports.toString)(expr.expr), "]");
            break;
        default:
            break;
    }
    return ret;
};
exports.toString = toString;
//# sourceMappingURL=xpathdebug.js.map