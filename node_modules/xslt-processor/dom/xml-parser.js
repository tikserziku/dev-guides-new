"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlParser = void 0;
var he_1 = __importDefault(require("he"));
var functions_1 = require("./functions");
var xdocument_1 = require("./xdocument");
var xmltoken_1 = require("./xmltoken");
var constants_1 = require("../constants");
/**
 * Original author: Steffen Meschkat <mesch@google.com> (the `xmlParse` function,
 * now `xmlStrictParse`).
 *
 * An XML parse and a minimal DOM implementation that just supports
 * the subset of the W3C DOM that is used in the XSLT implementation.
 */
var XmlParser = /** @class */ (function () {
    function XmlParser() {
        this.regexEmpty = /\/$/;
        this.XML10_TAGNAME_REGEXP = new RegExp("^(".concat(xmltoken_1.XML10_NAME, ")"));
        this.XML10_ATTRIBUTE_REGEXP = new RegExp(xmltoken_1.XML10_ATTRIBUTE, 'g');
        this.XML11_TAGNAME_REGEXP = new RegExp("^(".concat(xmltoken_1.XML11_NAME, ")"));
        this.XML11_ATTRIBUTE_REGEXP = new RegExp(xmltoken_1.XML11_ATTRIBUTE, 'g');
        this.lenientHtmlTags = ['hr', 'link', 'meta'];
    }
    /**
     * The entry point for this parser.
     * It verifies whether the document seems to be HTML.
     * HTML is a special case if XML and it should be parsed differently.
     * @param xmlOrHtml The XML or HTML content to be parsed.
     * @returns A DOM document.
     */
    XmlParser.prototype.xmlParse = function (xmlOrHtml) {
        if (xmlOrHtml.toUpperCase().startsWith('<!DOCTYPE HTML')) {
            return this.htmlParse(xmlOrHtml);
        }
        return this.xmlStrictParse(xmlOrHtml);
    };
    /**
     * Given an XNode, returns an object mapping prefixes to their corresponding namespaces in its scope.
     * Default namespace is treated as if its prefix were the empty string.
     * @param node The Node.
     * @returns An object with prefixes and namespace URLs.
     */
    XmlParser.prototype.namespaceMapAt = function (node) {
        var map = {
            // reserved namespaces: https://www.w3.org/TR/REC-xml-names/#xmlReserved
            xmlns: 'http://www.w3.org/2000/xmlns/',
            xml: 'http://www.w3.org/XML/1998/namespace'
        };
        var n = node;
        while (n !== null) {
            for (var i = 0; i < n.childNodes.length; i++) {
                var childNode = n.childNodes[i];
                if (childNode.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                    continue;
                }
                if (childNode.nodeName.startsWith('xmlns:')) {
                    var prefix = childNode.nodeName.split(':')[1];
                    if (!(prefix in map))
                        map[prefix] = childNode.nodeValue;
                }
                else if (childNode.nodeName == 'xmlns') {
                    if (!('' in map))
                        map[''] = childNode.nodeValue || null;
                }
            }
            n = n.parentNode;
        }
        return map;
    };
    /**
     * HTML needs to be parsed differently because it's a special case of XML.
     * Sources:
     *
     * - https://blog.teamtreehouse.com/to-close-or-not-to-close-tags-in-html5
     * @param htmlText The HTML text
     * @returns A DOM document.
     */
    XmlParser.prototype.htmlParse = function (htmlText) {
        var xmlDocument = new xdocument_1.XDocument();
        var root = xmlDocument;
        var stack = [];
        var parent = root;
        stack.push(parent);
        var tag = false, quotes = false, doublequotes = false, start = 0;
        for (var i = 0; i < htmlText.length; ++i) {
            var char = htmlText.charAt(i);
            if (tag) {
                if (!doublequotes && char === "'") {
                    quotes = !quotes;
                }
                else if (!quotes && char === '"') {
                    doublequotes = !doublequotes;
                }
                else if (!quotes && !doublequotes && char === '>') {
                    var text = htmlText.slice(start, i);
                    if (text.charAt(0) === '/') { //  {
                        stack.pop();
                        parent = stack[stack.length - 1];
                    }
                    else if (text.charAt(0) === '!') {
                        // Ignore comments
                        // console.log(`Ignored ${text}`);
                    }
                    else {
                        var empty = text.match(this.regexEmpty);
                        var tagName = this.XML10_TAGNAME_REGEXP.exec(text)[1];
                        var node = (0, functions_1.domCreateElement)(xmlDocument, tagName);
                        var attribute = void 0;
                        while ((attribute = this.XML10_ATTRIBUTE_REGEXP.exec(text))) {
                            var val = he_1.default.decode(attribute[5] || attribute[7] || '');
                            (0, functions_1.domSetAttribute)(node, attribute[1], val);
                        }
                        node.siblingPosition = parent.childNodes.length;
                        (0, functions_1.domAppendChild)(parent, node);
                        // The fundamental difference between this parse function
                        // and the strict XML parse is here:
                        // HTML is lenient with certain tags, that don't need to be closed.
                        if (!empty && !this.lenientHtmlTags.includes(tagName)) {
                            parent = node;
                            stack.push(node);
                        }
                    }
                    start = i + 1;
                    tag = false;
                    quotes = false;
                    doublequotes = false;
                }
            }
            else {
                if (char === '<') {
                    var text = htmlText.slice(start, i);
                    if (text && parent !== root) {
                        (0, functions_1.domAppendChild)(parent, (0, functions_1.domCreateTextNode)(xmlDocument, text));
                    }
                    if (htmlText.slice(i + 1, i + 4) === '!--') {
                        var endTagIndex = htmlText.slice(i + 4).indexOf('-->');
                        if (endTagIndex) {
                            var node = (0, functions_1.domCreateComment)(xmlDocument, htmlText.slice(i + 4, i + endTagIndex + 4));
                            (0, functions_1.domAppendChild)(parent, node);
                            i += endTagIndex + 6;
                        }
                    }
                    else if (htmlText.slice(i + 1, i + 9) === '!DOCTYPE') {
                        var endTagIndex = htmlText.slice(i + 9).indexOf('>');
                        if (endTagIndex) {
                            var dtdValue = htmlText.slice(i + 9, i + endTagIndex + 9).trimStart();
                            // TODO: Not sure if this is a good solution.
                            // Trying to implement this: https://github.com/DesignLiquido/xslt-processor/issues/30
                            var node = (0, functions_1.domCreateDTDSection)(xmlDocument, dtdValue);
                            (0, functions_1.domAppendChild)(parent, node);
                            i += endTagIndex + dtdValue.length + 5;
                        }
                    }
                    else {
                        tag = true;
                    }
                    start = i + 1;
                }
            }
        }
        return xmlDocument;
    };
    /**
     * Parses the given XML string with our custom, JavaScript XML parser.
     * @param xml The XML String.
     * @returns A XDocument.
     * @author Steffen Meschkat <mesch@google.com>
     */
    XmlParser.prototype.xmlStrictParse = function (xml) {
        var regexTagname;
        var regexAttribute;
        if (xml.match(/^<\?xml/)) {
            // When an XML document begins with an XML declaration
            // VersionInfo must appear.
            if (xml.search(new RegExp(xmltoken_1.XML10_VERSION_INFO)) === 5) {
                regexTagname = this.XML10_TAGNAME_REGEXP;
                regexAttribute = this.XML10_ATTRIBUTE_REGEXP;
            }
            else if (xml.search(new RegExp(xmltoken_1.XML11_VERSION_INFO)) === 5) {
                regexTagname = this.XML11_TAGNAME_REGEXP;
                regexAttribute = this.XML11_ATTRIBUTE_REGEXP;
            }
            else {
                throw new Error('XML VersionInfo has an unknown version number.');
            }
        }
        else {
            // When an XML declaration is missing it's an XML 1.0 document.
            regexTagname = this.XML10_TAGNAME_REGEXP;
            regexAttribute = this.XML10_ATTRIBUTE_REGEXP;
        }
        var xmlDocument = new xdocument_1.XDocument();
        var root = xmlDocument;
        var stack = [];
        var parent = root;
        stack.push(parent);
        var tag = false, quotes = false, doublequotes = false, start = 0;
        for (var i = 0; i < xml.length; ++i) {
            var char = xml.charAt(i);
            if (tag && !doublequotes && char === "'") {
                quotes = !quotes;
            }
            else if (tag && !quotes && char === '"') {
                doublequotes = !doublequotes;
            }
            else if (tag && char === '>' && !quotes && !doublequotes) {
                var text = xml.slice(start, i);
                if (text.charAt(0) === '/') {
                    stack.pop();
                    parent = stack[stack.length - 1];
                }
                else if (text.charAt(0) === '?') {
                    // Ignore XML declaration and processing instructions
                }
                else if (text.charAt(0) === '!') {
                    // Ignore comments
                    // console.log(`Ignored ${text}`);
                }
                else {
                    var empty = text.match(this.regexEmpty);
                    var tagname = regexTagname.exec(text)[1];
                    var node = (0, functions_1.domCreateElement)(xmlDocument, tagname);
                    var attribute = void 0;
                    while ((attribute = regexAttribute.exec(text))) {
                        var val = he_1.default.decode(attribute[5] || attribute[7] || '');
                        (0, functions_1.domSetAttribute)(node, attribute[1], val);
                    }
                    node.siblingPosition = parent.childNodes.length;
                    (0, functions_1.domAppendChild)(parent, node);
                    if (!empty) {
                        parent = node;
                        stack.push(node);
                    }
                    var namespaceMap = this.namespaceMapAt(node);
                    if (node.prefix !== null) {
                        if (node.prefix in namespaceMap)
                            node.namespaceUri = namespaceMap[node.prefix];
                        // else, prefix is undefined. do anything?
                    }
                    else {
                        if ('' in namespaceMap)
                            node.namespaceUri = namespaceMap[''];
                    }
                    for (var i_1 = 0; i_1 < node.childNodes.length; ++i_1) {
                        var childNode = node.childNodes[i_1];
                        if (childNode.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                            continue;
                        }
                        if (childNode.prefix !== null && childNode.prefix in namespaceMap) {
                            childNode.namespaceUri = namespaceMap[childNode.prefix];
                            // else, prefix undefined.
                        }
                        // elements with no prefix always have no namespace, so do nothing here.
                    }
                }
                start = i + 1;
                tag = false;
                quotes = false;
                doublequotes = false;
            }
            else if (!tag && char === '<') {
                var text = xml.slice(start, i);
                if (text && parent !== root) {
                    (0, functions_1.domAppendChild)(parent, (0, functions_1.domCreateTextNode)(xmlDocument, text));
                }
                if (xml.slice(i + 1, i + 4) === '!--') {
                    var endTagIndex = xml.slice(i + 4).indexOf('-->');
                    if (endTagIndex) {
                        var node = (0, functions_1.domCreateComment)(xmlDocument, xml.slice(i + 4, i + endTagIndex + 4));
                        (0, functions_1.domAppendChild)(parent, node);
                        i += endTagIndex + 6;
                    }
                }
                else if (xml.slice(i + 1, i + 9) === '![CDATA[') {
                    var endTagIndex = xml.slice(i + 9).indexOf(']]>');
                    if (endTagIndex) {
                        var node = (0, functions_1.domCreateCDATASection)(xmlDocument, xml.slice(i + 9, i + endTagIndex + 9));
                        (0, functions_1.domAppendChild)(parent, node);
                        i += endTagIndex + 11;
                    }
                }
                else if (xml.slice(i + 1, i + 9) === '!DOCTYPE') { // "!DOCTYPE" can be used in a XSLT template.
                    var endTagIndex = xml.slice(i + 9).indexOf('>');
                    if (endTagIndex) {
                        var dtdValue = xml.slice(i + 9, i + endTagIndex + 9).trimStart();
                        // TODO: Not sure if this is a good solution.
                        // Trying to implement this: https://github.com/DesignLiquido/xslt-processor/issues/30
                        var node = (0, functions_1.domCreateDTDSection)(xmlDocument, dtdValue);
                        (0, functions_1.domAppendChild)(parent, node);
                        i += endTagIndex + dtdValue.length + 5;
                    }
                }
                else {
                    tag = true;
                }
                start = i + 1;
            }
        }
        return root;
    };
    return XmlParser;
}());
exports.XmlParser = XmlParser;
//# sourceMappingURL=xml-parser.js.map