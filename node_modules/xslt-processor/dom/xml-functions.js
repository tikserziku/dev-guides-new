"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.xmlValue = xmlValue;
exports.xmlValueLegacyBehavior = xmlValueLegacyBehavior;
exports.xmlText = xmlText;
exports.xmlTransformedText = xmlTransformedText;
exports.xmlUnescapeText = xmlUnescapeText;
exports.xmlEscapeText = xmlEscapeText;
exports.xmlGetAttribute = xmlGetAttribute;
exports.xmlOwnerDocument = xmlOwnerDocument;
var he_1 = __importDefault(require("he"));
var constants_1 = require("../constants");
var functions_1 = require("./functions");
/**
 * Returns the text value of a node; for nodes without children this
 * is the nodeValue, for nodes with children this is the concatenation
 * of the value of all children. Browser-specific optimizations are used by
 * default; they can be disabled by passing "true" in as the second parameter.
 * @param node The Node (not exactly a `XNode` here).
 * @param disallowBrowserSpecificOptimization A boolean, to avoid browser optimization.
 * @returns The XML value as a string.
 */
function xmlValue(node, disallowBrowserSpecificOptimization) {
    if (disallowBrowserSpecificOptimization === void 0) { disallowBrowserSpecificOptimization = false; }
    if (!node) {
        return '';
    }
    var ret = '';
    switch (node.nodeType) {
        case constants_1.DOM_DOCUMENT_TYPE_NODE:
            return "<!DOCTYPE ".concat(node.nodeValue, ">");
        case constants_1.DOM_TEXT_NODE:
        case constants_1.DOM_CDATA_SECTION_NODE:
        case constants_1.DOM_ATTRIBUTE_NODE:
            return node.nodeValue;
        case constants_1.DOM_ELEMENT_NODE:
        case constants_1.DOM_DOCUMENT_NODE:
        case constants_1.DOM_DOCUMENT_FRAGMENT_NODE:
            if (!disallowBrowserSpecificOptimization) {
                // Only returns something if node has either `innerText` or `textContent` (not an XNode).
                // IE, Safari, Opera, and friends (`innerText`)
                var browserNode = node;
                var innerText = browserNode.innerText;
                if (innerText !== undefined) {
                    return innerText;
                }
                // Firefox (`textContent`)
                var textContent = browserNode.textContent;
                if (textContent !== undefined) {
                    return textContent;
                }
            }
            if (node.transformedChildNodes.length > 0) {
                var transformedTextNodes = node.transformedChildNodes.filter(function (n) { return n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE; });
                for (var i = 0; i < transformedTextNodes.length; ++i) {
                    ret += xmlValue(transformedTextNodes[i]);
                }
            }
            else {
                var textNodes = node.childNodes.filter(function (n) { return n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE; });
                for (var i = 0; i < textNodes.length; ++i) {
                    ret += xmlValue(textNodes[i]);
                }
            }
            return ret;
    }
}
/**
 * The older version to obtain a XML value from a node.
 * For now, this form is only used to get text from attribute nodes,
 * and it should be removed in future versions.
 * @param node The attribute node.
 * @param disallowBrowserSpecificOptimization A boolean, to avoid browser optimization.
 * @returns The XML value as a string.
 */
function xmlValueLegacyBehavior(node, disallowBrowserSpecificOptimization) {
    if (disallowBrowserSpecificOptimization === void 0) { disallowBrowserSpecificOptimization = false; }
    if (!node) {
        return '';
    }
    var returnedXmlString = '';
    switch (node.nodeType) {
        case constants_1.DOM_ATTRIBUTE_NODE:
        case constants_1.DOM_TEXT_NODE:
            returnedXmlString += node.nodeValue;
            break;
        case constants_1.DOM_CDATA_SECTION_NODE:
            returnedXmlString += node.nodeValue;
            break;
        case constants_1.DOM_DOCUMENT_NODE:
        case constants_1.DOM_DOCUMENT_FRAGMENT_NODE:
        case constants_1.DOM_ELEMENT_NODE:
            if (!disallowBrowserSpecificOptimization) {
                // IE, Safari, Opera, and friends
                var browserNode = node;
                var innerText = browserNode.innerText;
                if (innerText !== undefined) {
                    return innerText;
                }
                // Firefox
                var textContent = browserNode.textContent;
                if (textContent !== undefined) {
                    return textContent;
                }
            }
            var len = node.transformedChildNodes.length;
            for (var i = 0; i < len; ++i) {
                returnedXmlString += xmlValue(node.transformedChildNodes[i]);
            }
            break;
    }
    return returnedXmlString;
}
/**
 * Returns the representation of a node as XML text.
 * In general it is not used by XSLT, that uses `xmlTransformedText` instead.
 * @param {XNode} node The starting node.
 * @param {XmlOutputOptions} options XML output options.
 * @returns The XML string.
 * @see xmlTransformedText
 */
function xmlText(node, options) {
    if (options === void 0) { options = {
        cData: true,
        escape: true,
        selfClosingTags: true,
        outputMethod: 'xml'
    }; }
    var buffer = [];
    xmlTextRecursive(node, buffer, options);
    return buffer.join('');
}
/**
 * The recursive logic to transform a node in XML text.
 * It can be considered legacy, since it does not work with transformed nodes, and
 * probably will be removed in the future.
 * @param {XNode} node The node.
 * @param {string[]} buffer The buffer, that will represent the transformed XML text.
 * @param {XmlOutputOptions} options XML output options.
 */
function xmlTextRecursive(node, buffer, options) {
    if (node.nodeType == constants_1.DOM_TEXT_NODE) {
        buffer.push(xmlEscapeText(node.nodeValue));
    }
    else if (node.nodeType == constants_1.DOM_CDATA_SECTION_NODE) {
        if (options.cData) {
            buffer.push(node.nodeValue);
        }
        else {
            buffer.push("<![CDATA[".concat(node.nodeValue, "]]>"));
        }
    }
    else if (node.nodeType == constants_1.DOM_COMMENT_NODE) {
        buffer.push("<!--".concat(node.nodeValue, "-->"));
    }
    else if (node.nodeType == constants_1.DOM_ELEMENT_NODE) {
        buffer.push("<".concat(xmlFullNodeName(node)));
        for (var i = 0; i < node.childNodes.length; ++i) {
            var childNode = node.childNodes[i];
            if (!childNode || childNode.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                continue;
            }
            if (childNode.nodeName && childNode.nodeValue) {
                buffer.push(" ".concat(xmlFullNodeName(childNode), "=\"").concat(xmlEscapeAttr(childNode.nodeValue), "\""));
            }
        }
        if (node.childNodes.length === 0) {
            if (options.selfClosingTags ||
                (options.outputMethod === 'html' && ['hr', 'link'].includes(node.nodeName))) {
                buffer.push('/>');
            }
            else {
                buffer.push("></".concat(xmlFullNodeName(node), ">"));
            }
        }
        else {
            buffer.push('>');
            for (var i = 0; i < node.childNodes.length; ++i) {
                xmlTextRecursive(node.childNodes[i], buffer, options);
            }
            buffer.push("</".concat(xmlFullNodeName(node), ">"));
        }
    }
    else if (node.nodeType == constants_1.DOM_DOCUMENT_NODE || node.nodeType == constants_1.DOM_DOCUMENT_FRAGMENT_NODE) {
        for (var i = 0; i < node.childNodes.length; ++i) {
            xmlTextRecursive(node.childNodes[i], buffer, options);
        }
    }
}
/**
 * Returns the representation of a node as XML text.
 * @param {XNode} node The starting node.
 * @param {XmlOutputOptions} options XML output options.
 * @returns The XML string.
 */
function xmlTransformedText(node, options) {
    if (options === void 0) { options = {
        cData: true,
        escape: true,
        selfClosingTags: true,
        outputMethod: 'xml'
    }; }
    var buffer = [];
    xmlTransformedTextRecursive(node, buffer, options);
    return buffer.join('');
}
/**
 * The recursive logic to transform a node in XML text.
 * @param {XNode} node The node.
 * @param {string[]} buffer The buffer, that will represent the transformed XML text.
 * @param {XmlOutputOptions} options XML output options.
 */
function xmlTransformedTextRecursive(node, buffer, options) {
    if (node.visited)
        return;
    var nodeType = node.transformedNodeType || node.nodeType;
    var nodeValue = node.transformedNodeValue || node.nodeValue;
    if (nodeType === constants_1.DOM_TEXT_NODE) {
        if (node.transformedNodeValue && node.transformedNodeValue.trim() !== '') {
            var finalText = node.escape && options.escape ? xmlEscapeText(node.transformedNodeValue) : xmlUnescapeText(node.transformedNodeValue);
            buffer.push(finalText);
        }
    }
    else if (nodeType === constants_1.DOM_CDATA_SECTION_NODE) {
        if (options.cData) {
            buffer.push(xmlEscapeText(nodeValue));
        }
        else {
            buffer.push("<![CDATA[".concat(nodeValue, "]]>"));
        }
    }
    else if (nodeType == constants_1.DOM_COMMENT_NODE) {
        buffer.push("<!-- ".concat(nodeValue, " -->"));
    }
    else if (nodeType == constants_1.DOM_ELEMENT_NODE) {
        // If node didn't have a transformed name, but its children
        // had transformations, children should be present at output.
        // This is called here "muted logic".
        if (node.transformedNodeName !== null && node.transformedNodeName !== undefined) {
            xmlElementLogicTrivial(node, buffer, options);
        }
        else {
            xmlElementLogicMuted(node, buffer, options);
        }
    }
    else if (nodeType === constants_1.DOM_DOCUMENT_NODE || nodeType === constants_1.DOM_DOCUMENT_FRAGMENT_NODE) {
        var childNodes = node.transformedChildNodes.concat(node.childNodes);
        childNodes.sort(function (a, b) { return a.siblingPosition - b.siblingPosition; });
        for (var i = 0; i < childNodes.length; ++i) {
            xmlTransformedTextRecursive(childNodes[i], buffer, options);
        }
    }
    node.visited = true;
}
/**
 * XML element output, trivial logic.
 * @param node The XML node.
 * @param buffer The XML buffer.
 * @param cdata If using CDATA configuration.
 */
function xmlElementLogicTrivial(node, buffer, options) {
    buffer.push("<".concat(xmlFullNodeName(node)));
    var attributes = node.transformedChildNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
    if (attributes.length === 0) {
        attributes = node.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
    }
    for (var i = 0; i < attributes.length; ++i) {
        var attribute = attributes[i];
        if (!attribute) {
            continue;
        }
        if (attribute.transformedNodeName && attribute.transformedNodeValue) {
            buffer.push(" ".concat(xmlFullNodeName(attribute), "=\"").concat(xmlEscapeAttr(attribute.transformedNodeValue), "\""));
        }
    }
    var childNodes = node.transformedChildNodes.filter(function (n) { return n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE; });
    if (childNodes.length === 0) {
        childNodes = node.childNodes.filter(function (n) { return n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE; });
    }
    childNodes = childNodes.sort(function (a, b) { return a.siblingPosition - b.siblingPosition; });
    if (childNodes.length === 0) {
        if (options.outputMethod === 'html' && ['hr', 'link', 'meta'].includes(node.nodeName)) {
            buffer.push('>');
        }
        else if (options.selfClosingTags) {
            buffer.push('/>');
        }
        else {
            buffer.push("></".concat(xmlFullNodeName(node), ">"));
        }
    }
    else {
        buffer.push('>');
        for (var i = 0; i < childNodes.length; ++i) {
            xmlTransformedTextRecursive(childNodes[i], buffer, options);
        }
        buffer.push("</".concat(xmlFullNodeName(node), ">"));
    }
}
/**
 * XML element output, muted logic.
 * In other words, this element should not be printed, but its
 * children can be printed if they have transformed values.
 * @param node The XML node.
 * @param buffer The XML buffer.
 * @param cdata If using CDATA configuration.
 */
function xmlElementLogicMuted(node, buffer, options) {
    var childNodes = node.transformedChildNodes.length > 0 ? node.transformedChildNodes : node.childNodes;
    childNodes = childNodes.sort(function (a, b) { return a.siblingPosition - b.siblingPosition; });
    for (var i = 0; i < childNodes.length; ++i) {
        xmlTransformedTextRecursive(childNodes[i], buffer, options);
    }
}
/**
 * Gets the full node name.
 * When namespace is set, the node name is `namespace:node`.
 * @param node The node.
 * @returns The full node name as a string.
 */
function xmlFullNodeName(node) {
    var nodeName = node.transformedNodeName || node.nodeName;
    if (node.transformedPrefix && nodeName.indexOf("".concat(node.transformedPrefix, ":")) != 0) {
        return "".concat(node.transformedPrefix, ":").concat(nodeName);
    }
    return nodeName;
}
/**
 * Replaces HTML/XML entities to their literal characters.
 * Currently implementing only tag delimiters.
 * @param text The text to be transformed.
 * @returns The unescaped text.
 */
function xmlUnescapeText(text) {
    return "".concat(text).replace(/&lt;/g, '<').replace(/&gt;/g, '>');
}
/**
 * Escape XML special markup characters: tag delimiter <, >, and entity
 * reference start delimiter &. The escaped string can be used in XML
 * text portions (i.e. between tags).
 * @param s The string to be escaped.
 * @returns The escaped string.
 */
function xmlEscapeText(s) {
    return "".concat(s)
        .replace(/&/g, '&amp;')
        .replace(/&amp;amp;/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}
/**
 * Escape XML special markup characters: tag delimiter, <, >, entity
 * reference start delimiter &, and double quotes ("). The escaped string can be
 * used in double quoted XML attribute value portions (i.e. in
 * attributes within start tags).
 * @param s The string to be escaped.
 * @returns The escaped string.
 */
function xmlEscapeAttr(s) {
    return xmlEscapeText(s).replace(/"/g, '&quot;');
}
/**
 * Wrapper function to access attribute values of template element
 * nodes. Currently this calls he.decode because in some DOM
 * implementations the return value of node.getAttributeValue()
 * contains unresolved XML entities, although the DOM spec requires
 * that entity references are resolved by the DOM.
 * @param node TODO
 * @param name TODO
 * @returns TODO
 */
function xmlGetAttribute(node, name) {
    // TODO(mesch): This should not be necessary if the DOM is working
    // correctly. The DOM is responsible for resolving entities, not the
    // application.
    var value = (0, functions_1.domGetAttributeValue)(node, name);
    if (value) {
        return he_1.default.decode(value);
    }
    return value;
}
/**
 * Wrapper function to access the owner document uniformly for document
 * and other nodes: for the document node, the owner document is the
 * node itself, for all others it's the ownerDocument property.
 *
 * @param {XNode} node
 * @return {XDocument}
 */
function xmlOwnerDocument(node) {
    if (node === null || node === undefined) {
        throw new Error('Node has no valid owner document.');
    }
    if (node.nodeType === constants_1.DOM_DOCUMENT_NODE) {
        return node;
    }
    return xmlOwnerDocument(node.ownerDocument);
}
//# sourceMappingURL=xml-functions.js.map