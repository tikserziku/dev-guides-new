"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XNode = void 0;
var constants_1 = require("../constants");
// operate on native DOM nodes.
/**
 * Our W3C DOM Node implementation. Note we call it XNode because we
 * can't define the identifier Node. We do this mostly for Opera,
 * where we can't reuse the HTML DOM for parsing our own XML, and for
 * Safari, where it is too expensive to have the template processor.
 */
var XNode = /** @class */ (function () {
    function XNode(type, name, opt_value, opt_owner, opt_namespace) {
        this.id = Math.random() * (Number.MAX_SAFE_INTEGER - 1) + 1;
        this.childNodes = [];
        this.transformedChildNodes = [];
        this.visited = false;
        this.escape = true;
        this.siblingPosition = -1;
        this.init(type, name, opt_value, opt_owner, opt_namespace);
    }
    /**
     * Node initialization. Called by the constructor and `recycle` method.
     * @param type The node type.
     * @param name The node name.
     * @param value The node value.
     * @param owner The node owner.
     * @param namespaceUri The node namespace.
     */
    XNode.prototype.init = function (type, name, value, owner, namespaceUri) {
        var _a;
        this.nodeType = type - 0;
        this.nodeName = "".concat(name);
        this.nodeValue = "".concat(value);
        this.ownerDocument = owner;
        this.namespaceUri = namespaceUri || null;
        _a = this.qualifiedNameToParts("".concat(name)), this.prefix = _a[0], this.localName = _a[1];
        this.firstChild = null;
        this.lastChild = null;
        this.nextSibling = null;
        this.previousSibling = null;
        this.parentNode = null;
    };
    XNode.prototype.qualifiedNameToParts = function (name) {
        if (name.includes(':')) {
            return name.split(':');
        }
        return [null, name];
    };
    // Traverses the element nodes in the DOM section underneath the given
    // node and invokes the given callbacks as methods on every element
    // node encountered. Function opt_pre is invoked before a node's
    // children are traversed; opt_post is invoked after they are
    // traversed. Traversal will not be continued if a callback function
    // returns boolean false. NOTE(mesch): copied from
    // <//google3/maps/webmaps/javascript/dom.js>.
    XNode.prototype.domTraverseElements = function (node, opt_pre, opt_post) {
        var ret;
        if (opt_pre) {
            ret = opt_pre.call(null, node);
            if (typeof ret == 'boolean' && !ret) {
                return false;
            }
        }
        for (var c = node.firstChild; c; c = c.nextSibling) {
            if (c.nodeType == constants_1.DOM_ELEMENT_NODE) {
                ret = this.domTraverseElements.call(this, c, opt_pre, opt_post);
                if (typeof ret == 'boolean' && !ret) {
                    return false;
                }
            }
        }
        if (opt_post) {
            ret = opt_post.call(null, node);
            if (typeof ret == 'boolean' && !ret) {
                return false;
            }
        }
    };
    // TODO: Do we still need this?
    XNode.recycle = function (node) {
        if (!node) {
            return;
        }
        if (node.constructor.name === 'XDocument') {
            this.recycle(node.documentElement);
            return;
        }
        if (node.constructor != this) {
            return;
        }
        this._unusedXNodes.push(node);
        /* for (let a = 0; a < node.attributes.length; ++a) {
            this.recycle(node.attributes[a]);
        } */
        for (var c = 0; c < node.childNodes.length; ++c) {
            this.recycle(node.childNodes[c]);
        }
        // node.attributes.length = 0;
        node.childNodes.length = 0;
        node.init.call(0, '', '', null);
    };
    XNode.create = function (type, name, value, owner, namespace) {
        if (this._unusedXNodes.length > 0) {
            var node = this._unusedXNodes.pop();
            node.init(type, name, value, owner, namespace);
            return node;
        }
        return new XNode(type, name, value, owner, namespace);
    };
    XNode.clone = function (node, newOwner) {
        var newNode = new XNode(node.nodeType, node.nodeName, node.nodeValue, newOwner, node.namespaceUri);
        newNode.id = node.id;
        for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
            var child = _a[_i];
            newNode.appendChild(XNode.clone(child, newNode));
        }
        /* for (let attribute of node.attributes) {
            newNode.setAttribute(attribute.nodeName, attribute.nodeValue);
        } */
        return newNode;
    };
    XNode.prototype.appendChild = function (node) {
        // firstChild
        if (this.childNodes.length === 0) {
            this.firstChild = node;
        }
        // previousSibling
        node.previousSibling = this.lastChild;
        // nextSibling
        node.nextSibling = null;
        if (this.lastChild) {
            this.lastChild.nextSibling = node;
        }
        // parentNode
        node.parentNode = this;
        // lastChild
        this.lastChild = node;
        // childNodes
        this.childNodes.push(node);
    };
    XNode.prototype.appendTransformedChild = function (node) {
        // firstChild
        if (this.transformedChildNodes.length === 0) {
            this.transformedFirstChild = node;
        }
        // previousSibling
        node.transformedPreviousSibling = this.lastChild;
        // nextSibling
        node.transformedNextSibling = null;
        if (this.transformedLastChild) {
            this.transformedLastChild.transformedNextSibling = node;
        }
        // parentNode
        node.transformedParentNode = this;
        // lastChild
        this.transformedLastChild = node;
        // childNodes
        this.transformedChildNodes.push(node);
    };
    XNode.prototype.replaceChild = function (newNode, oldNode) {
        if (oldNode == newNode) {
            return;
        }
        for (var i = 0; i < this.childNodes.length; ++i) {
            if (this.childNodes[i] == oldNode) {
                this.childNodes[i] = newNode;
                var p = oldNode.parentNode;
                oldNode.parentNode = null;
                newNode.parentNode = p;
                p = oldNode.previousSibling;
                oldNode.previousSibling = null;
                newNode.previousSibling = p;
                if (newNode.previousSibling) {
                    newNode.previousSibling.nextSibling = newNode;
                }
                p = oldNode.nextSibling;
                oldNode.nextSibling = null;
                newNode.nextSibling = p;
                if (newNode.nextSibling) {
                    newNode.nextSibling.previousSibling = newNode;
                }
                if (this.firstChild == oldNode) {
                    this.firstChild = newNode;
                }
                if (this.lastChild == oldNode) {
                    this.lastChild = newNode;
                }
                break;
            }
        }
    };
    XNode.prototype.insertBefore = function (newNode, oldNode) {
        if (oldNode == newNode) {
            return;
        }
        if (oldNode.parentNode != this) {
            return;
        }
        if (newNode.parentNode) {
            newNode.parentNode.removeChild(newNode);
        }
        var newChildren = [];
        for (var _i = 0, _a = this.childNodes; _i < _a.length; _i++) {
            var c = _a[_i];
            if (c == oldNode) {
                newChildren.push(newNode);
                newNode.parentNode = this;
                newNode.previousSibling = oldNode.previousSibling;
                oldNode.previousSibling = newNode;
                if (newNode.previousSibling) {
                    newNode.previousSibling.nextSibling = newNode;
                }
                newNode.nextSibling = oldNode;
                if (this.firstChild == oldNode) {
                    this.firstChild = newNode;
                }
            }
            newChildren.push(c);
        }
        this.childNodes = newChildren;
    };
    XNode.prototype.removeChild = function (node) {
        var newChildren = [];
        for (var _i = 0, _a = this.childNodes; _i < _a.length; _i++) {
            var c = _a[_i];
            if (c != node) {
                newChildren.push(c);
            }
            else {
                if (c.previousSibling) {
                    c.previousSibling.nextSibling = c.nextSibling;
                }
                if (c.nextSibling) {
                    c.nextSibling.previousSibling = c.previousSibling;
                }
                if (this.firstChild == c) {
                    this.firstChild = c.nextSibling;
                }
                if (this.lastChild == c) {
                    this.lastChild = c.previousSibling;
                }
            }
        }
        this.childNodes = newChildren;
    };
    XNode.prototype.hasAttributes = function () {
        var attributes = this.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
        return attributes.length > 0;
    };
    XNode.prototype.setAttribute = function (name, value) {
        var attributes = this.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
        for (var i = 0; i < attributes.length; ++i) {
            if (attributes[i].nodeName == name) {
                attributes[i].nodeValue = "".concat(value);
                return;
            }
        }
        var newAttribute = XNode.create(constants_1.DOM_ATTRIBUTE_NODE, name, value, this);
        newAttribute.parentNode = this;
        this.appendChild(newAttribute);
    };
    XNode.prototype.setTransformedAttribute = function (name, value) {
        var transformedAttributes = this.transformedChildNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
        for (var i = 0; i < transformedAttributes.length; ++i) {
            var transformedAttribute = transformedAttributes[i];
            if (transformedAttribute.nodeName === name) {
                transformedAttribute.transformedNodeName = name;
                transformedAttribute.transformedNodeValue = "".concat(value);
                return;
            }
        }
        var newAttribute = XNode.create(constants_1.DOM_ATTRIBUTE_NODE, name, value, this);
        newAttribute.transformedNodeName = name;
        newAttribute.transformedNodeValue = value;
        newAttribute.parentNode = this;
        this.appendTransformedChild(newAttribute);
    };
    XNode.prototype.setAttributeNS = function (namespace, name, value) {
        var attributes = this.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
        for (var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];
            if (attribute.namespaceUri == namespace &&
                attribute.localName == this.qualifiedNameToParts("".concat(name))[1]) {
                attribute.nodeValue = "".concat(value);
                attribute.nodeName = "".concat(name);
                attribute.prefix = this.qualifiedNameToParts("".concat(name))[0];
                return;
            }
        }
        var newAttribute = XNode.create(constants_1.DOM_ATTRIBUTE_NODE, name, value, this, namespace);
        newAttribute.parentNode = this;
        this.appendChild(newAttribute);
    };
    XNode.prototype.getAttributeValue = function (name) {
        var attributes = this.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
        for (var i = 0; i < attributes.length; ++i) {
            if (attributes[i].nodeName === name) {
                return attributes[i].nodeValue;
            }
        }
        return null;
    };
    XNode.prototype.getAttributeNS = function (namespace, localName) {
        var attributes = this.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
        for (var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];
            if (attribute.namespaceUri === namespace && attribute.localName === localName) {
                return attribute.nodeValue;
            }
        }
        return null;
    };
    XNode.prototype.hasAttribute = function (name) {
        var attributes = this.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
        for (var i = 0; i < attributes.length; ++i) {
            if (attributes[i].nodeName === name) {
                return true;
            }
        }
        return false;
    };
    XNode.prototype.hasAttributeNS = function (namespace, localName) {
        var attributes = this.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
        for (var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];
            if (attribute.namespaceUri === namespace && attribute.localName === localName) {
                return true;
            }
        }
        return false;
    };
    XNode.prototype.removeAttribute = function (name) {
        var newChildNodes = [];
        for (var i = 0; i < this.childNodes.length; ++i) {
            var childNode = this.childNodes[i];
            if (childNode.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                newChildNodes.push(childNode);
                continue;
            }
            if (childNode.nodeName !== name) {
                newChildNodes.push(childNode);
            }
        }
        this.childNodes = newChildNodes;
    };
    XNode.prototype.removeAttributeNS = function (namespace, localName) {
        var newChildNodes = [];
        for (var i = 0; i < this.childNodes.length; ++i) {
            var childNode = this.childNodes[i];
            if (childNode.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                newChildNodes.push(childNode);
                continue;
            }
            if (childNode.localName !== localName || childNode.namespaceUri !== namespace) {
                newChildNodes.push(childNode);
            }
        }
        this.childNodes = newChildNodes;
    };
    XNode.prototype.getElementsByTagName = function (name) {
        var ret = [];
        var self = this;
        if ('*' == name) {
            this.domTraverseElements(this, function (node) {
                if (self == node)
                    return;
                ret.push(node);
            }, null);
        }
        else {
            this.domTraverseElements(this, function (node) {
                if (self == node)
                    return;
                if (node.nodeName == name) {
                    ret.push(node);
                }
            }, null);
        }
        return ret;
    };
    XNode.prototype.getElementsByTagNameNS = function (namespace, localName) {
        var ret = [];
        var self = this;
        if ('*' == namespace && '*' == localName) {
            this.domTraverseElements(this, function (node) {
                if (self == node)
                    return;
                ret.push(node);
            }, null);
        }
        else if ('*' == namespace) {
            this.domTraverseElements(this, function (node) {
                if (self == node)
                    return;
                if (node.localName == localName)
                    ret.push(node);
            }, null);
        }
        else if ('*' == localName) {
            this.domTraverseElements(this, function (node) {
                if (self == node)
                    return;
                if (node.namespaceUri == namespace)
                    ret.push(node);
            }, null);
        }
        else {
            this.domTraverseElements(this, function (node) {
                if (self == node)
                    return;
                if (node.localName == localName && node.namespaceUri == namespace) {
                    ret.push(node);
                }
            }, null);
        }
        return ret;
    };
    XNode.prototype.getElementById = function (id) {
        var ret = null;
        this.domTraverseElements(this, function (node) {
            if (node.getAttributeValue('id') == id) {
                ret = node;
                return false;
            }
        }, null);
        return ret;
    };
    XNode.prototype.getAncestorByLocalName = function (localName) {
        if (this.parentNode === null || this.parentNode === undefined) {
            return undefined;
        }
        if (this.parentNode.localName === localName) {
            return this.parentNode;
        }
        return this.parentNode.getAncestorByLocalName(localName);
    };
    XNode.prototype.getAncestorById = function (id) {
        if (this.parentNode === null || this.parentNode === undefined) {
            return undefined;
        }
        if (this.parentNode.id === id) {
            return this.parentNode;
        }
        return this.parentNode.getAncestorById(id);
    };
    XNode._unusedXNodes = [];
    return XNode;
}());
exports.XNode = XNode;
//# sourceMappingURL=xnode.js.map