import { ExprContext } from './expr-context';
import { BinaryExpr, FunctionCallExpr, LiteralExpr, LocationExpr, NumberExpr, PathExpr, PredicateExpr, StepExpr, TokenExpr, UnaryMinusExpr, UnionExpr, VariableExpr } from './expressions';
import { Expression } from './expressions/expression';
import { XPathTokenRule } from './xpath-token-rule';
import { XNode } from '../dom';
import { NodeTestAny, NodeTestElementOrAttribute, NodeTestNC, NodeTestName, NodeTestText, NodeTestComment, NodeTestPI, NodeTest } from './node-tests';
import { NodeValue } from './values';
export declare class XPath {
    xPathParseCache: any;
    xPathRules: any[];
    xPathLog: (message: string) => void;
    lexerCount: number;
    parseCount: number;
    reduceCount: number;
    xPathGrammarRules: ((number | {
        label: string;
        key: any;
    } | (XPathTokenRule | {
        label: string;
        key: any;
    })[] | ((rel: any, slash: any, step: any) => any))[] | (number | {
        label: string;
        key: any;
    } | {
        label: string;
        key: any;
    }[] | ((nodeTest: any, axis?: string) => StepExpr))[] | (number | {
        label: string;
        key: any;
    } | {
        label: string;
    }[] | ((name: any, pareno: any, arg1: any, args: any) => FunctionCallExpr))[] | (number | {
        label: string;
        key: any;
    } | {
        label: string;
    }[] | ((expr: any, predicates: any) => any))[] | (number | boolean | {
        label: string;
        key: any;
    } | (XPathTokenRule | {
        label: string;
        key: any;
    })[] | ((expr1: any, op: any, expr2: any) => BinaryExpr))[])[];
    constructor();
    makeTokenExpr(m: any): TokenExpr;
    passExpr(e: any): any;
    makeLocationExpr1(slash: any, rel: any): any;
    makeLocationExpr2(dslash: any, rel: any): any;
    makeLocationExpr3(): LocationExpr;
    makeLocationExpr4(dslash: any): LocationExpr;
    makeLocationExpr5(step: any): LocationExpr;
    makeLocationExpr6(rel: any, slash: any, step: any): any;
    makeLocationExpr7(rel: any, dslash: any, step: any): any;
    makeStepExpr1(dot: any): StepExpr;
    makeStepExpr2(ddot: any): StepExpr;
    makeStepExpr3(axisname: any, axis: any, nodeTest: any): StepExpr;
    makeStepExpr4(at: any, nodeTest: any): StepExpr;
    makeStepExpr5(nodeTest: any, axis?: string): StepExpr;
    makeStepExpr6(step: any, predicate: any): any;
    makeAbbrevStep(abbrev: any): StepExpr;
    makeNodeTestExpr1(): NodeTestElementOrAttribute;
    makeNodeTestExpr2(ncname: any): NodeTestNC;
    makeNodeTestExpr3(qname: TokenExpr): NodeTestName;
    makeNodeTestExpr4(typeo: any): NodeTestAny | NodeTestComment | NodeTestPI | NodeTestText;
    makeNodeTestExpr5(typeo: any, target: any): NodeTestPI;
    makePredicateExpr(pareno: any, expression: any): PredicateExpr;
    makePrimaryExpr(pareno: any, expression: any): any;
    makeFunctionCallExpr1(name: any): FunctionCallExpr;
    makeFunctionCallExpr2(name: any, pareno: any, arg1: any, args: any): FunctionCallExpr;
    makeArgumentExpr(comma: any, expression: any): any;
    makeUnionExpr(expr1: Expression, pipe: TokenExpr, expr2: Expression): UnionExpr;
    makePathExpr1(filter: any, slash: any, rel: any): PathExpr;
    makePathExpr2(filter: any, dslash: any, rel: any): PathExpr;
    makeFilterExpr(expr: any, predicates: any): any;
    makeUnaryMinusExpr(minus: any, expr: any): UnaryMinusExpr;
    makeBinaryExpr(expr1: any, op: any, expr2: any): BinaryExpr;
    makeLiteralExpr(token: any): LiteralExpr;
    makeNumberExpr(token: any): NumberExpr;
    makeVariableReference(dollar: any, name: any): VariableExpr;
    /**
     * Used before parsing for optimization of common simple cases. See
     * the begin of xPathParse() for which they are.
     * @param expression The XPath expression.
     * @param axis The axis, if required. Default is 'child'.
     * @returns An `Expression` object.
     */
    makeSimpleExpr(expression: string, axis?: string): Expression;
    makeSimpleExpr2(expr: any): LocationExpr;
    stackToString(stack: any[]): string;
    xPathCacheLookup(expr: any): any;
    xPathCollectDescendants(nodeList: XNode[], node: XNode, opt_tagName?: string): void;
    xPathCollectDescendantsReverse(nodeList: any, node: any): void;
    /**
     * Parses and then evaluates the given XPath expression in the given
     * input context.
     * @param select The xPath string.
     * @param context The Expression Context.
     * @returns A Node Value.
     */
    xPathEval(select: string, context: ExprContext): NodeValue;
    /**
     * DGF - extract a tag name suitable for getElementsByTagName
     *
     * @param nodeTest                     the node test
     * @param ignoreNonElementNodesForNTA  if true, the node list returned when
     *                                     evaluating "node()" will not contain
     *                                     non-element nodes. This can boost
     *                                     performance. This is false by default.
     */
    xPathExtractTagNameFromNodeTest(nodeTest: NodeTest, ignoreNonElementNodesForNTA: any): string;
    xPathMatchStack(stack: any[], pattern: any[]): any;
    /**
     * Finds the best rule for the XPath expression provided.
     * @param expression The XPath string expression.
     * @param previous The previous matched XPath rule.
     * @returns The found rule and the corresponding match.
     */
    private findXPathRuleForExpression;
    /**
     * Initialization for `xPathParse`.
     * @see xPathParse
     */
    private xPathParseInit;
    /**
     * The entry point for the parser.
     * @param expression a string that contains an XPath expression.
     * @param axis The XPath axis. Used when the match does not start with the parent.
     * @returns an expression object that can be evaluated with an
     * expression context.
     */
    xPathParse(expression: string, axis?: string): any;
    private findGrammarRuleCandidate;
    /**
     * DGF xPathReduce is where the magic happens in this parser.
     * Check `src\xpath\xpath-grammar-rules.ts` to find the table of
     * grammatical rules and precedence numbers, "The productions of the grammar".
     *
     * The idea here is that we want to take a stack of tokens and apply
     * grammatical rules to them, "reducing" them to higher-level
     * tokens. Ultimately, any valid XPath should reduce to exactly one
     * "Expr" token.
     *
     * Reduce too early or too late, and you'll have two tokens that can't reduce
     * to single Expr. For example, you may hastily reduce a qname that
     * should name a function, incorrectly treating it as a tag name.
     * Or you may reduce too late, accidentally reducing the last part of the
     * XPath into a top-level "Expr" that won't reduce with earlier parts of
     * the XPath.
     *
     * A "candidate" is a grammatical rule candidate, with a given precedence
     * number. "ahead" is the upcoming token, which also has a precedence
     * number. If the token has a higher precedence number than
     * the rule candidate, we'll "shift" the token onto the token stack,
     * instead of immediately applying the rule candidate.
     *
     * Some tokens have left associativity, in which case we shift when they
     * have LOWER precedence than the candidate.
     * @param stack The actual grammar rule stack.
     * @param ahead The grammar rule ahead.
     * @return `true` if a grammar rule candidate was applied. `false` otherwise.
     * @private
     */
    private xPathReduce;
    /**
     * Utility function to sort a list of nodes. Used by xsltSort().
     * @param context The Expression Context.
     * @param sort TODO
     */
    xPathSort(context: ExprContext, sort: any[]): void;
    xPathSortByKey(v1: any, v2: any): number;
    xPathStep(nodes: any[], steps: any[], step: any, input: XNode, context: ExprContext): void;
    xPathGrammarPrecedence(frame: any): number;
    xPathTokenPrecedence(tag: any): any;
}
