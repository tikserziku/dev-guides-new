"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryExpr = void 0;
var dom_1 = require("../../dom");
var boolean_value_1 = require("../values/boolean-value");
var number_value_1 = require("../values/number-value");
var expression_1 = require("./expression");
var BinaryExpr = /** @class */ (function (_super) {
    __extends(BinaryExpr, _super);
    function BinaryExpr(expr1, op, expr2) {
        var _this = _super.call(this) || this;
        _this.expr1 = expr1;
        _this.expr2 = expr2;
        _this.op = op;
        return _this;
    }
    BinaryExpr.prototype.evaluate = function (ctx) {
        var ret;
        switch (this.op.value) {
            case 'or':
                ret = new boolean_value_1.BooleanValue(this.expr1.evaluate(ctx).booleanValue() || this.expr2.evaluate(ctx).booleanValue());
                break;
            case 'and':
                ret = new boolean_value_1.BooleanValue(this.expr1.evaluate(ctx).booleanValue() && this.expr2.evaluate(ctx).booleanValue());
                break;
            case '+':
                ret = new number_value_1.NumberValue(this.expr1.evaluate(ctx).numberValue() + this.expr2.evaluate(ctx).numberValue());
                break;
            case '-':
                ret = new number_value_1.NumberValue(this.expr1.evaluate(ctx).numberValue() - this.expr2.evaluate(ctx).numberValue());
                break;
            case '*':
                ret = new number_value_1.NumberValue(this.expr1.evaluate(ctx).numberValue() * this.expr2.evaluate(ctx).numberValue());
                break;
            case 'mod':
                ret = new number_value_1.NumberValue(this.expr1.evaluate(ctx).numberValue() % this.expr2.evaluate(ctx).numberValue());
                break;
            case 'div':
                ret = new number_value_1.NumberValue(this.expr1.evaluate(ctx).numberValue() / this.expr2.evaluate(ctx).numberValue());
                break;
            case '=':
                ret = this.compare(ctx, function (x1, x2) { return x1 == x2; });
                break;
            case '!=':
                ret = this.compare(ctx, function (x1, x2) { return x1 != x2; });
                break;
            case '<':
                ret = this.compare(ctx, function (x1, x2) { return x1 < x2; });
                break;
            case '<=':
                ret = this.compare(ctx, function (x1, x2) { return x1 <= x2; });
                break;
            case '>':
                ret = this.compare(ctx, function (x1, x2) { return x1 > x2; });
                break;
            case '>=':
                ret = this.compare(ctx, function (x1, x2) { return x1 >= x2; });
                break;
            default:
                throw "BinaryExpr.evaluate: ".concat(this.op.value);
        }
        return ret;
    };
    BinaryExpr.prototype.compare = function (ctx, cmp) {
        var v1 = this.expr1.evaluate(ctx);
        var v2 = this.expr2.evaluate(ctx);
        var ret;
        if (v1.type == 'node-set' && v2.type == 'node-set') {
            var n1 = v1.nodeSetValue();
            var n2 = v2.nodeSetValue();
            ret = false;
            for (var i1 = 0; i1 < n1.length; ++i1) {
                for (var i2 = 0; i2 < n2.length; ++i2) {
                    if (cmp((0, dom_1.xmlValue)(n1[i1]), (0, dom_1.xmlValue)(n2[i2]))) {
                        ret = true;
                        // Break outer loop. Labels confuse the jscompiler and we
                        // don't use them.
                        i2 = n2.length;
                        i1 = n1.length;
                    }
                }
            }
        }
        else if (v1.type == 'node-set' || v2.type == 'node-set') {
            if (v1.type == 'number') {
                var s = v1.numberValue();
                var n = v2.nodeSetValue();
                ret = false;
                for (var i = 0; i < n.length; ++i) {
                    var nn = parseInt((0, dom_1.xmlValue)(n[i])) - 0;
                    if (cmp(s, nn)) {
                        ret = true;
                        break;
                    }
                }
            }
            else if (v2.type == 'number') {
                var n = v1.nodeSetValue();
                var s = v2.numberValue();
                ret = false;
                for (var i = 0; i < n.length; ++i) {
                    var nn = parseInt((0, dom_1.xmlValue)(n[i])) - 0;
                    if (cmp(nn, s)) {
                        ret = true;
                        break;
                    }
                }
            }
            else if (v1.type == 'string') {
                var s = v1.stringValue();
                var n = v2.nodeSetValue();
                ret = false;
                for (var i = 0; i < n.length; ++i) {
                    var nn = (0, dom_1.xmlValue)(n[i]);
                    if (cmp(s, nn)) {
                        ret = true;
                        break;
                    }
                }
            }
            else if (v2.type == 'string') {
                var n = v1.nodeSetValue();
                var s = v2.stringValue();
                ret = false;
                for (var i = 0; i < n.length; ++i) {
                    var nn = (0, dom_1.xmlValue)(n[i]);
                    if (cmp(nn, s)) {
                        ret = true;
                        break;
                    }
                }
            }
            else {
                ret = cmp(v1.booleanValue(), v2.booleanValue());
            }
        }
        else if (v1.type == 'boolean' || v2.type == 'boolean') {
            ret = cmp(v1.booleanValue(), v2.booleanValue());
        }
        else if (v1.type == 'number' || v2.type == 'number') {
            ret = cmp(v1.numberValue(), v2.numberValue());
        }
        else {
            ret = cmp(v1.stringValue(), v2.stringValue());
        }
        return new boolean_value_1.BooleanValue(ret);
    };
    return BinaryExpr;
}(expression_1.Expression));
exports.BinaryExpr = BinaryExpr;
//# sourceMappingURL=binary-expr.js.map