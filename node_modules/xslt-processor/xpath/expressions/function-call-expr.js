"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionCallExpr = void 0;
var functions_1 = require("../functions");
var non_standard_1 = require("../functions/non-standard");
var standard_20_1 = require("../functions/standard-20");
var boolean_value_1 = require("../values/boolean-value");
var expression_1 = require("./expression");
var FunctionCallExpr = /** @class */ (function (_super) {
    __extends(FunctionCallExpr, _super);
    function FunctionCallExpr(name) {
        var _this = _super.call(this) || this;
        _this.xPathFunctions = {
            boolean: functions_1.boolean,
            ceiling: functions_1.ceiling,
            concat: functions_1.concat,
            contains: functions_1.contains,
            count: functions_1.count,
            current: functions_1.current,
            'ends-with': functions_1.endsWith,
            false: functions_1._false,
            'format-number': functions_1.formatNumber,
            floor: functions_1.floor,
            'generate-id': functions_1.generateId,
            id: functions_1.id,
            key: functions_1.key,
            lang: functions_1.lang,
            last: functions_1.last,
            'local-name': functions_1.localName,
            'lower-case': standard_20_1.lowerCase,
            'replace': standard_20_1._replace,
            matches: functions_1.matches,
            name: functions_1._name,
            'namespace-uri': functions_1.namespaceUri,
            'normalize-space': functions_1.normalizeSpace,
            not: functions_1.not,
            number: functions_1.number,
            position: functions_1.position,
            round: functions_1.round,
            'starts-with': functions_1.startsWith,
            string: functions_1._string,
            'xml-to-json': functions_1.xmlToJson,
            substring: functions_1.substring,
            'substring-before': functions_1.substringBefore,
            'substring-after': functions_1.substringAfter,
            sum: functions_1.sum,
            'string-length': functions_1.stringLength,
            translate: functions_1.translate,
            true: functions_1._true,
            'upper-case': standard_20_1.upperCase,
            // TODO(mesch): The following functions are custom. There is a
            // standard that defines how to add functions, which should be
            // applied here.
            'ext-join': non_standard_1.extJoin,
            // ext-if() evaluates and returns its second argument, if the
            // boolean value of its first argument is true, otherwise it
            // evaluates and returns its third argument.
            'ext-if': non_standard_1.extIf,
            // ext-cardinal() evaluates its single argument as a number, and
            // returns the current node that many times. It can be used in the
            // select attribute to iterate over an integer range.
            'ext-cardinal': non_standard_1.extCardinal
        };
        _this.name = name;
        _this.args = [];
        return _this;
    }
    FunctionCallExpr.prototype.appendArg = function (arg) {
        this.args.push(arg);
    };
    FunctionCallExpr.prototype.evaluate = function (context) {
        var functionName = "".concat(this.name.value);
        var resolvedFunction = this.xPathFunctions[functionName];
        if (resolvedFunction) {
            return resolvedFunction.call(this, context);
        }
        return new boolean_value_1.BooleanValue(false);
    };
    return FunctionCallExpr;
}(expression_1.Expression));
exports.FunctionCallExpr = FunctionCallExpr;
//# sourceMappingURL=function-call-expr.js.map