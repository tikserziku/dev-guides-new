"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.StepExpr = void 0;
var constants_1 = require("../../constants");
var dom_1 = require("../../dom");
var node_set_value_1 = require("../values/node-set-value");
var node_test_any_1 = require("../node-tests/node-test-any");
var tokens_1 = require("../tokens");
var expression_1 = require("./expression");
var binary_expr_1 = require("./binary-expr");
var function_call_expr_1 = require("./function-call-expr");
var number_expr_1 = require("./number-expr");
var unary_minus_expr_1 = require("./unary-minus-expr");
var common_function_1 = require("../common-function");
var StepExpr = /** @class */ (function (_super) {
    __extends(StepExpr, _super);
    function StepExpr(axis, nodeTest, xPath, opt_predicate) {
        var _this = _super.call(this) || this;
        _this.axis = axis;
        _this.nodeTest = nodeTest;
        _this.predicate = opt_predicate || [];
        _this.hasPositionalPredicate = false;
        _this.xPath = xPath;
        for (var i = 0; i < _this.predicate.length; ++i) {
            if (_this.predicateExprHasPositionalSelector(_this.predicate[i].expr)) {
                _this.hasPositionalPredicate = true;
                break;
            }
        }
        return _this;
    }
    /**
     * Determines whether a predicate expression contains a "positional selector".
     * A positional selector filters nodes from the nodeList input based on their
     * position within that list. When such selectors are encountered, the
     * evaluation of the predicate cannot be depth-first, because the positional
     * selector may be based on the result of evaluating predicates that precede
     * it.
     */
    StepExpr.prototype.predicateExprHasPositionalSelector = function (expr, isRecursiveCall) {
        if (!expr) {
            return false;
        }
        if (!isRecursiveCall && this.exprReturnsNumberValue(expr)) {
            // this is a "proximity position"-based predicate
            return true;
        }
        if (expr instanceof function_call_expr_1.FunctionCallExpr) {
            var value = expr.name.value;
            return value == 'last' || value == 'position';
        }
        if (expr instanceof binary_expr_1.BinaryExpr) {
            return (this.predicateExprHasPositionalSelector(expr.expr1, true) ||
                this.predicateExprHasPositionalSelector(expr.expr2, true));
        }
        return false;
    };
    StepExpr.prototype.exprReturnsNumberValue = function (expr) {
        if (expr instanceof function_call_expr_1.FunctionCallExpr) {
            var isMember = {
                last: true,
                position: true,
                count: true,
                'string-length': true,
                number: true,
                sum: true,
                floor: true,
                ceiling: true,
                round: true
            };
            return isMember[expr.name.value];
        }
        if (expr instanceof unary_minus_expr_1.UnaryMinusExpr) {
            return true;
        }
        if (expr instanceof binary_expr_1.BinaryExpr) {
            var isMember = {
                '+': true,
                '-': true,
                '*': true,
                mod: true,
                div: true
            };
            return isMember[expr.op.value];
        }
        if (expr instanceof number_expr_1.NumberExpr) {
            return true;
        }
        return false;
    };
    StepExpr.prototype.appendPredicate = function (predicateExpression) {
        this.predicate.push(predicateExpression);
        if (!this.hasPositionalPredicate) {
            this.hasPositionalPredicate = this.predicateExprHasPositionalSelector(predicateExpression.expression);
        }
    };
    StepExpr.prototype.evaluate = function (context) {
        var node = context.nodeList[context.position];
        var nodeList = [];
        var skipNodeTest = false;
        if (this.nodeTest instanceof node_test_any_1.NodeTestAny) {
            skipNodeTest = true;
        }
        switch (this.axis) {
            case tokens_1.xPathAxis.ANCESTOR_OR_SELF:
                nodeList.push(node);
                for (var n = node.parentNode; n; n = n.parentNode) {
                    if (n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                        nodeList.push(n);
                    }
                }
                break;
            case tokens_1.xPathAxis.ANCESTOR:
                for (var n = node.parentNode; n; n = n.parentNode) {
                    if (n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                        nodeList.push(n);
                    }
                }
                break;
            case tokens_1.xPathAxis.ATTRIBUTE:
                var attributes = node.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
                if (this.nodeTest.name !== undefined) {
                    // single-attribute step
                    if (attributes) {
                        if (attributes instanceof Array) {
                            // probably evaluating on document created by xmlParse()
                            (0, common_function_1.copyArray)(nodeList, attributes);
                        }
                        else {
                            // TODO: I think this `else` does't make any sense now.
                            // Before unifying attributes with child nodes, `node.attributes` was always an array.
                            if (this.nodeTest.name == 'style') {
                                var value = node.getAttributeValue('style');
                                if (value && typeof value != 'string') {
                                    // this is the case where indexing into the attributes array
                                    // doesn't give us the attribute node in IE - we create our own
                                    // node instead
                                    nodeList.push(dom_1.XNode.create(constants_1.DOM_ATTRIBUTE_NODE, 'style', value.cssText, document));
                                }
                                else {
                                    nodeList.push(attributes[this.nodeTest.name]);
                                }
                            }
                            else {
                                nodeList.push(attributes[this.nodeTest.name]);
                            }
                        }
                    }
                }
                else {
                    // all-attributes step
                    if (context.ignoreAttributesWithoutValue) {
                        (0, common_function_1.copyArrayIgnoringAttributesWithoutValue)(nodeList, attributes);
                    }
                    else {
                        (0, common_function_1.copyArray)(nodeList, attributes);
                    }
                }
                break;
            case tokens_1.xPathAxis.CHILD:
                (0, common_function_1.copyArray)(nodeList, node.childNodes.filter(function (n) { return n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE; }));
                break;
            case tokens_1.xPathAxis.DESCENDANT_OR_SELF: {
                if (this.nodeTest.evaluate(context).booleanValue()) {
                    nodeList.push(node);
                }
                var tagName = this.xPath.xPathExtractTagNameFromNodeTest(this.nodeTest, context.ignoreNonElementNodesForNTA);
                this.xPath.xPathCollectDescendants(nodeList, node, tagName);
                if (tagName)
                    skipNodeTest = true;
                break;
            }
            case tokens_1.xPathAxis.DESCENDANT: {
                var tagName = this.xPath.xPathExtractTagNameFromNodeTest(this.nodeTest, context.ignoreNonElementNodesForNTA);
                this.xPath.xPathCollectDescendants(nodeList, node, tagName);
                if (tagName)
                    skipNodeTest = true;
                break;
            }
            case tokens_1.xPathAxis.FOLLOWING:
                for (var n = node; n; n = n.parentNode) {
                    for (var nn = n.nextSibling; nn; nn = nn.nextSibling) {
                        if (nn.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                            nodeList.push(nn);
                        }
                        this.xPath.xPathCollectDescendants(nodeList, nn);
                    }
                }
                break;
            case tokens_1.xPathAxis.FOLLOWING_SIBLING:
                if (node.nodeType === constants_1.DOM_ATTRIBUTE_NODE) {
                    break;
                }
                for (var n = node.nextSibling; n; n = n.nextSibling) {
                    if (n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                        nodeList.push(n);
                    }
                }
                break;
            case tokens_1.xPathAxis.NAMESPACE:
                throw new Error('not implemented: axis namespace');
            case tokens_1.xPathAxis.PARENT:
                if (node.parentNode) {
                    nodeList.push(node.parentNode);
                }
                break;
            case tokens_1.xPathAxis.PRECEDING:
                for (var n = node; n; n = n.parentNode) {
                    for (var nn = n.previousSibling; nn; nn = nn.previousSibling) {
                        if (nn.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                            nodeList.push(nn);
                        }
                        this.xPath.xPathCollectDescendantsReverse(nodeList, nn);
                    }
                }
                break;
            case tokens_1.xPathAxis.PRECEDING_SIBLING:
                for (var n = node.previousSibling; n; n = n.previousSibling) {
                    if (n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                        nodeList.push(n);
                    }
                }
                break;
            case tokens_1.xPathAxis.SELF:
                nodeList.push(node);
                break;
            case tokens_1.xPathAxis.SELF_AND_SIBLINGS:
                for (var _i = 0, _a = context.nodeList; _i < _a.length; _i++) {
                    var node_1 = _a[_i];
                    if (node_1.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                        nodeList.push(node_1);
                    }
                }
                break;
            default:
                throw new Error("ERROR -- NO SUCH AXIS: ".concat(this.axis));
        }
        if (!skipNodeTest) {
            // process node test
            var nodeList0 = nodeList;
            nodeList = [];
            for (var i = 0; i < nodeList0.length; ++i) {
                if (this.nodeTest.evaluate(context.clone(nodeList0, undefined, i)).booleanValue()) {
                    nodeList.push(nodeList0[i]);
                }
            }
        }
        // process predicates
        if (!context.returnOnFirstMatch) {
            for (var i = 0; i < this.predicate.length; ++i) {
                var nodeList0 = nodeList;
                nodeList = [];
                for (var ii = 0; ii < nodeList0.length; ++ii) {
                    var n = nodeList0[ii];
                    if (this.predicate[i].evaluate(context.clone(nodeList0, undefined, ii)).booleanValue()) {
                        nodeList.push(n);
                    }
                }
            }
        }
        return new node_set_value_1.NodeSetValue(nodeList);
    };
    return StepExpr;
}(expression_1.Expression));
exports.StepExpr = StepExpr;
//# sourceMappingURL=step-expr.js.map