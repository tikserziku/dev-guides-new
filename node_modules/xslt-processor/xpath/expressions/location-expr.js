"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocationExpr = void 0;
var node_set_value_1 = require("../values/node-set-value");
var node_test_any_1 = require("../node-tests/node-test-any");
var tokens_1 = require("../tokens");
var expression_1 = require("./expression");
var LocationExpr = /** @class */ (function (_super) {
    __extends(LocationExpr, _super);
    function LocationExpr(xPath) {
        var _this = _super.call(this) || this;
        _this.absolute = false;
        _this.steps = [];
        _this.xPath = xPath;
        return _this;
    }
    LocationExpr.prototype.appendStep = function (s) {
        var combinedStep = this._combineSteps(this.steps[this.steps.length - 1], s);
        if (combinedStep) {
            this.steps[this.steps.length - 1] = combinedStep;
        }
        else {
            this.steps.push(s);
        }
    };
    LocationExpr.prototype.prependStep = function (s) {
        var combinedStep = this._combineSteps(s, this.steps[0]);
        if (combinedStep) {
            this.steps[0] = combinedStep;
        }
        else {
            this.steps.unshift(s);
        }
    };
    // DGF try to combine two steps into one step (perf enhancement)
    LocationExpr.prototype._combineSteps = function (prevStep, nextStep) {
        if (!prevStep)
            return null;
        if (!nextStep)
            return null;
        var hasPredicates = prevStep.predicates && prevStep.predicates.length > 0;
        if (prevStep.nodeTest instanceof node_test_any_1.NodeTestAny && !hasPredicates) {
            // maybe suitable to be combined
            if (prevStep.axis == tokens_1.xPathAxis.DESCENDANT_OR_SELF) {
                if (nextStep.axis == tokens_1.xPathAxis.CHILD) {
                    // HBC - commenting out, because this is not a valid reduction
                    //nextStep.axis = xpathAxis.DESCENDANT;
                    //return nextStep;
                }
                else if (nextStep.axis == tokens_1.xPathAxis.SELF) {
                    nextStep.axis = tokens_1.xPathAxis.DESCENDANT_OR_SELF;
                    return nextStep;
                }
            }
            else if (prevStep.axis == tokens_1.xPathAxis.DESCENDANT) {
                if (nextStep.axis == tokens_1.xPathAxis.SELF) {
                    nextStep.axis = tokens_1.xPathAxis.DESCENDANT;
                    return nextStep;
                }
            }
        }
        return null;
    };
    LocationExpr.prototype.evaluate = function (context) {
        var start;
        if (this.absolute) {
            start = context.root;
        }
        else {
            start = context.nodeList[context.position];
            // TODO: `<xsl:template>` with relative path, starting on root node,
            // conflicts with `<xsl:template match="/">`, for some reason considered as relative.
            /* if (start.nodeName === '#document' && this.steps[0].axis === 'self-and-siblings') {
                start = start.childNodes[0];
            } */
        }
        var nodes = [];
        this.xPath.xPathStep(nodes, this.steps, 0, start, context);
        return new node_set_value_1.NodeSetValue(nodes);
    };
    return LocationExpr;
}(expression_1.Expression));
exports.LocationExpr = LocationExpr;
//# sourceMappingURL=location-expr.js.map