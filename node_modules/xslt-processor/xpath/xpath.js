"use strict";
// Copyright 2023-2024 Design Liquido
// Copyright 2018 Johannes Wilm
// Copyright 2005 Google Inc.
// All Rights Reserved
//
// An XPath parser and evaluator written in JavaScript. The
// implementation is complete except for functions handling
// namespaces.
//
// Reference: [XPATH] XPath Specification
// <http://www.w3.org/TR/1999/REC-xpath-19991116>.
//
//
// The API of the parser has several parts:
//
// 1. The parser function xpathParse() that takes a string and returns
// an expession object.
//
// 2. The expression object that has an evaluate() method to evaluate the
// XPath expression it represents. (It is actually a hierarchy of
// objects that resembles the parse tree, but an application will call
// evaluate() only on the top node of this hierarchy.)
//
// 3. The context object that is passed as an argument to the evaluate()
// method, which represents the DOM context in which the expression is
// evaluated.
//
// 4. The value object that is returned from evaluate() and represents
// values of the different types that are defined by XPath (number,
// string, boolean, and node-set), and allows to convert between them.
//
// These parts are near the top of the file, the functions and data
// that are used internally follow after them.
//
//
// Original author: Steffen Meschkat <mesch@google.com>
Object.defineProperty(exports, "__esModule", { value: true });
exports.XPath = void 0;
var util_1 = require("../dom/util");
var common_function_1 = require("./common-function");
var expressions_1 = require("./expressions");
var tokens_1 = require("./tokens");
var xpath_grammar_rules_1 = require("./xpath-grammar-rules");
var node_tests_1 = require("./node-tests");
var constants_1 = require("../constants");
var XPath = /** @class */ (function () {
    function XPath() {
        // The productions of the grammar. Columns of the table:
        //
        // - target non-terminal,
        // - pattern,
        // - precedence,
        // - semantic value factory
        //
        // The semantic value factory is a function that receives parse tree
        // nodes from the stack frames of the matched symbols as arguments and
        // returns an a node of the parse tree. The node is stored in the top
        // stack frame along with the target object of the rule. The node in
        // the parse tree is an expression object that has an evaluate() method
        // and thus evaluates XPath expressions.
        //
        // The precedence is used to decide between reducing and shifting by
        // comparing the precedence of the rule that is candidate for
        // reducing with the precedence of the look ahead token. Precedence of
        // -1 means that the precedence of the tokens in the pattern is used
        // instead. TODO: It shouldn't be necessary to explicitly assign
        // precedences to rules.
        // DGF As it stands, these precedences are purely empirical; we're
        // not sure if they can be made to be consistent at all.
        this.xPathGrammarRules = [
            [xpath_grammar_rules_1.XPathLocationPath, [xpath_grammar_rules_1.XPathRelativeLocationPath], 18, this.passExpr],
            [xpath_grammar_rules_1.XPathLocationPath, [xpath_grammar_rules_1.XPathAbsoluteLocationPath], 18, this.passExpr],
            [xpath_grammar_rules_1.XPathAbsoluteLocationPath, [tokens_1.TOK_SLASH, xpath_grammar_rules_1.XPathRelativeLocationPath], 18, this.makeLocationExpr1],
            [xpath_grammar_rules_1.XPathAbsoluteLocationPath, [tokens_1.TOK_DSLASH, xpath_grammar_rules_1.XPathRelativeLocationPath], 18, this.makeLocationExpr2],
            [xpath_grammar_rules_1.XPathAbsoluteLocationPath, [tokens_1.TOK_SLASH], 0, this.makeLocationExpr3],
            [xpath_grammar_rules_1.XPathAbsoluteLocationPath, [tokens_1.TOK_DSLASH], 0, this.makeLocationExpr4],
            [xpath_grammar_rules_1.XPathRelativeLocationPath, [xpath_grammar_rules_1.XPathStep], 31, this.makeLocationExpr5],
            [xpath_grammar_rules_1.XPathRelativeLocationPath, [xpath_grammar_rules_1.XPathRelativeLocationPath, tokens_1.TOK_SLASH, xpath_grammar_rules_1.XPathStep], 31, this.makeLocationExpr6],
            [xpath_grammar_rules_1.XPathRelativeLocationPath, [xpath_grammar_rules_1.XPathRelativeLocationPath, tokens_1.TOK_DSLASH, xpath_grammar_rules_1.XPathStep], 31, this.makeLocationExpr7],
            [xpath_grammar_rules_1.XPathStep, [tokens_1.TOK_DOT], 33, this.makeStepExpr1],
            [xpath_grammar_rules_1.XPathStep, [tokens_1.TOK_DDOT], 33, this.makeStepExpr2],
            [xpath_grammar_rules_1.XPathStep, [tokens_1.TOK_AXISNAME, tokens_1.TOK_AXIS, xpath_grammar_rules_1.XPathNodeTest], 33, this.makeStepExpr3],
            [xpath_grammar_rules_1.XPathStep, [tokens_1.TOK_AT, xpath_grammar_rules_1.XPathNodeTest], 33, this.makeStepExpr4],
            [xpath_grammar_rules_1.XPathStep, [xpath_grammar_rules_1.XPathNodeTest], 33, this.makeStepExpr5],
            [xpath_grammar_rules_1.XPathStep, [xpath_grammar_rules_1.XPathStep, xpath_grammar_rules_1.XPathPredicate], 33, this.makeStepExpr6],
            [xpath_grammar_rules_1.XPathNodeTest, [tokens_1.TOK_ASTERISK], 33, this.makeNodeTestExpr1],
            [xpath_grammar_rules_1.XPathNodeTest, [tokens_1.TOK_NCNAME, tokens_1.TOK_COLON, tokens_1.TOK_ASTERISK], 33, this.makeNodeTestExpr2],
            [xpath_grammar_rules_1.XPathNodeTest, [tokens_1.TOK_QNAME], 33, this.makeNodeTestExpr3],
            [xpath_grammar_rules_1.XPathNodeTest, [tokens_1.TOK_NODEO, tokens_1.TOK_PARENC], 33, this.makeNodeTestExpr4],
            [xpath_grammar_rules_1.XPathNodeTest, [tokens_1.TOK_NODEO, xpath_grammar_rules_1.XPathLiteral, tokens_1.TOK_PARENC], 33, this.makeNodeTestExpr5],
            [xpath_grammar_rules_1.XPathPredicate, [tokens_1.TOK_BRACKO, xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_BRACKC], 33, this.makePredicateExpr],
            [xpath_grammar_rules_1.XPathPrimaryExpr, [xpath_grammar_rules_1.XPathVariableReference], 33, this.passExpr],
            [xpath_grammar_rules_1.XPathPrimaryExpr, [tokens_1.TOK_PARENO, xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_PARENC], 33, this.makePrimaryExpr],
            [xpath_grammar_rules_1.XPathPrimaryExpr, [xpath_grammar_rules_1.XPathLiteral], 30, this.passExpr],
            [xpath_grammar_rules_1.XPathPrimaryExpr, [xpath_grammar_rules_1.XPathNumber], 30, this.passExpr],
            [xpath_grammar_rules_1.XPathPrimaryExpr, [xpath_grammar_rules_1.XPathFunctionCall], 31, this.passExpr],
            [xpath_grammar_rules_1.XPathFunctionCall, [tokens_1.TOK_QNAME, tokens_1.TOK_PARENO, tokens_1.TOK_PARENC], -1, this.makeFunctionCallExpr1],
            [
                xpath_grammar_rules_1.XPathFunctionCall,
                [tokens_1.TOK_QNAME, tokens_1.TOK_PARENO, xpath_grammar_rules_1.XPathExpr, xpath_grammar_rules_1.XPathArgumentRemainder, tokens_1.Q_ZERO_OR_MULTIPLE, tokens_1.TOK_PARENC],
                -1,
                this.makeFunctionCallExpr2
            ],
            [xpath_grammar_rules_1.XPathArgumentRemainder, [tokens_1.TOK_COMMA, xpath_grammar_rules_1.XPathExpr], -1, this.makeArgumentExpr],
            [xpath_grammar_rules_1.XPathUnionExpr, [xpath_grammar_rules_1.XPathPathExpr], 20, this.passExpr],
            [xpath_grammar_rules_1.XPathUnionExpr, [xpath_grammar_rules_1.XPathUnionExpr, tokens_1.TOK_PIPE, xpath_grammar_rules_1.XPathPathExpr], 20, this.makeUnionExpr],
            [xpath_grammar_rules_1.XPathPathExpr, [xpath_grammar_rules_1.XPathLocationPath], 20, this.passExpr],
            [xpath_grammar_rules_1.XPathPathExpr, [xpath_grammar_rules_1.XPathFilterExpr], 19, this.passExpr],
            [xpath_grammar_rules_1.XPathPathExpr, [xpath_grammar_rules_1.XPathFilterExpr, tokens_1.TOK_SLASH, xpath_grammar_rules_1.XPathRelativeLocationPath], 19, this.makePathExpr1],
            [xpath_grammar_rules_1.XPathPathExpr, [xpath_grammar_rules_1.XPathFilterExpr, tokens_1.TOK_DSLASH, xpath_grammar_rules_1.XPathRelativeLocationPath], 19, this.makePathExpr2],
            [xpath_grammar_rules_1.XPathFilterExpr, [xpath_grammar_rules_1.XPathPrimaryExpr, xpath_grammar_rules_1.XPathPredicate, tokens_1.Q_ZERO_OR_MULTIPLE], 31, this.makeFilterExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathPrimaryExpr], 16, this.passExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathUnionExpr], 16, this.passExpr],
            [xpath_grammar_rules_1.XPathExpr, [tokens_1.TOK_MINUS, xpath_grammar_rules_1.XPathExpr], -1, this.makeUnaryMinusExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_OR, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_AND, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_EQ, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_NEQ, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_LT, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_LE, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_GT, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_GE, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_PLUS, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr, tokens_1.ASSOC_LEFT],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_MINUS, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr, tokens_1.ASSOC_LEFT],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_ASTERISK, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr, tokens_1.ASSOC_LEFT],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_DIV, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr, tokens_1.ASSOC_LEFT],
            [xpath_grammar_rules_1.XPathExpr, [xpath_grammar_rules_1.XPathExpr, tokens_1.TOK_MOD, xpath_grammar_rules_1.XPathExpr], -1, this.makeBinaryExpr, tokens_1.ASSOC_LEFT],
            [xpath_grammar_rules_1.XPathLiteral, [tokens_1.TOK_LITERALQ], -1, this.makeLiteralExpr],
            [xpath_grammar_rules_1.XPathLiteral, [tokens_1.TOK_LITERALQQ], -1, this.makeLiteralExpr],
            [xpath_grammar_rules_1.XPathNumber, [tokens_1.TOK_NUMBER], -1, this.makeNumberExpr],
            [xpath_grammar_rules_1.XPathVariableReference, [tokens_1.TOK_DOLLAR, tokens_1.TOK_QNAME], 200, this.makeVariableReference]
        ];
        this.xPathParseCache = {};
        this.xPathRules = [];
        this.xPathLog = function () { };
        this.lexerCount = 0;
        this.parseCount = 0;
        this.reduceCount = 0;
    }
    // Factory functions for semantic values (i.e. Expressions) of the
    // productions in the grammar. When a production is matched to reduce
    // the current parse state stack, the export function is called with the
    // semantic values of the matched elements as arguments, and returns
    // another semantic value. The semantic value is a node of the parse
    // tree, an expression object with an evaluate() method that evaluates the
    // expression in an actual context. These factory functions are used
    // in the specification of the grammar rules, below.
    XPath.prototype.makeTokenExpr = function (m) {
        return new expressions_1.TokenExpr(m);
    };
    XPath.prototype.passExpr = function (e) {
        return e;
    };
    XPath.prototype.makeLocationExpr1 = function (slash, rel) {
        rel.absolute = true;
        return rel;
    };
    XPath.prototype.makeLocationExpr2 = function (dslash, rel) {
        rel.absolute = true;
        rel.prependStep(this.makeAbbrevStep(dslash.value));
        return rel;
    };
    XPath.prototype.makeLocationExpr3 = function () {
        var ret = new expressions_1.LocationExpr(this);
        ret.appendStep(this.makeAbbrevStep('.'));
        ret.absolute = true;
        return ret;
    };
    XPath.prototype.makeLocationExpr4 = function (dslash) {
        var ret = new expressions_1.LocationExpr(this);
        ret.absolute = true;
        ret.appendStep(this.makeAbbrevStep(dslash.value));
        return ret;
    };
    XPath.prototype.makeLocationExpr5 = function (step) {
        var ret = new expressions_1.LocationExpr(this);
        ret.appendStep(step);
        return ret;
    };
    XPath.prototype.makeLocationExpr6 = function (rel, slash, step) {
        rel.appendStep(step);
        return rel;
    };
    XPath.prototype.makeLocationExpr7 = function (rel, dslash, step) {
        rel.appendStep(this.makeAbbrevStep(dslash.value));
        rel.appendStep(step);
        return rel;
    };
    XPath.prototype.makeStepExpr1 = function (dot) {
        return this.makeAbbrevStep(dot.value);
    };
    XPath.prototype.makeStepExpr2 = function (ddot) {
        return this.makeAbbrevStep(ddot.value);
    };
    XPath.prototype.makeStepExpr3 = function (axisname, axis, nodeTest) {
        return new expressions_1.StepExpr(axisname.value, nodeTest, this);
    };
    XPath.prototype.makeStepExpr4 = function (at, nodeTest) {
        return new expressions_1.StepExpr('attribute', nodeTest, this);
    };
    XPath.prototype.makeStepExpr5 = function (nodeTest, axis) {
        return new expressions_1.StepExpr(axis || 'child', nodeTest, this);
    };
    XPath.prototype.makeStepExpr6 = function (step, predicate) {
        step.appendPredicate(predicate);
        return step;
    };
    XPath.prototype.makeAbbrevStep = function (abbrev) {
        switch (abbrev) {
            case '//':
                return new expressions_1.StepExpr('descendant-or-self', new node_tests_1.NodeTestAny(), this);
            case '.':
                return new expressions_1.StepExpr('self', new node_tests_1.NodeTestAny(), this);
            case '..':
                return new expressions_1.StepExpr('parent', new node_tests_1.NodeTestAny(), this);
        }
    };
    XPath.prototype.makeNodeTestExpr1 = function () {
        return new node_tests_1.NodeTestElementOrAttribute();
    };
    XPath.prototype.makeNodeTestExpr2 = function (ncname) {
        return new node_tests_1.NodeTestNC(ncname.value);
    };
    XPath.prototype.makeNodeTestExpr3 = function (qname) {
        return new node_tests_1.NodeTestName(qname.value);
    };
    XPath.prototype.makeNodeTestExpr4 = function (typeo) {
        var type = typeo.value.replace(/\s*\($/, '');
        switch (type) {
            case 'node':
                return new node_tests_1.NodeTestAny();
            case 'text':
                return new node_tests_1.NodeTestText();
            case 'comment':
                return new node_tests_1.NodeTestComment();
            case 'processing-instruction':
                return new node_tests_1.NodeTestPI('');
        }
    };
    XPath.prototype.makeNodeTestExpr5 = function (typeo, target) {
        var type = typeo.replace(/\s*\($/, '');
        if (type != 'processing-instruction') {
            throw type;
        }
        return new node_tests_1.NodeTestPI(target.value);
    };
    XPath.prototype.makePredicateExpr = function (pareno, expression) {
        return new expressions_1.PredicateExpr(expression);
    };
    XPath.prototype.makePrimaryExpr = function (pareno, expression) {
        return expression;
    };
    XPath.prototype.makeFunctionCallExpr1 = function (name) {
        return new expressions_1.FunctionCallExpr(name);
    };
    XPath.prototype.makeFunctionCallExpr2 = function (name, pareno, arg1, args) {
        var ret = new expressions_1.FunctionCallExpr(name);
        ret.appendArg(arg1);
        for (var i = 0; i < args.length; ++i) {
            ret.appendArg(args[i]);
        }
        return ret;
    };
    XPath.prototype.makeArgumentExpr = function (comma, expression) {
        return expression;
    };
    XPath.prototype.makeUnionExpr = function (expr1, pipe, expr2) {
        return new expressions_1.UnionExpr(expr1, expr2);
    };
    XPath.prototype.makePathExpr1 = function (filter, slash, rel) {
        return new expressions_1.PathExpr(filter, rel);
    };
    XPath.prototype.makePathExpr2 = function (filter, dslash, rel) {
        rel.prependStep(this.makeAbbrevStep(dslash.value));
        return new expressions_1.PathExpr(filter, rel);
    };
    XPath.prototype.makeFilterExpr = function (expr, predicates) {
        if (predicates.length > 0) {
            return new expressions_1.FilterExpr(expr, predicates);
        }
        return expr;
    };
    XPath.prototype.makeUnaryMinusExpr = function (minus, expr) {
        return new expressions_1.UnaryMinusExpr(expr);
    };
    XPath.prototype.makeBinaryExpr = function (expr1, op, expr2) {
        return new expressions_1.BinaryExpr(expr1, op, expr2);
    };
    XPath.prototype.makeLiteralExpr = function (token) {
        // remove quotes from the parsed value:
        var value = token.value.substring(1, token.value.length - 1);
        return new expressions_1.LiteralExpr(value);
    };
    XPath.prototype.makeNumberExpr = function (token) {
        return new expressions_1.NumberExpr(token.value);
    };
    XPath.prototype.makeVariableReference = function (dollar, name) {
        return new expressions_1.VariableExpr(name.value);
    };
    /**
     * Used before parsing for optimization of common simple cases. See
     * the begin of xPathParse() for which they are.
     * @param expression The XPath expression.
     * @param axis The axis, if required. Default is 'child'.
     * @returns An `Expression` object.
     */
    XPath.prototype.makeSimpleExpr = function (expression, axis) {
        if (expression.charAt(0) == '$') {
            return new expressions_1.VariableExpr(expression.substr(1));
        }
        if (expression.charAt(0) == '@') {
            var a_1 = new node_tests_1.NodeTestName(expression.substr(1));
            var b_1 = new expressions_1.StepExpr('attribute', a_1, this);
            var c_1 = new expressions_1.LocationExpr(this);
            c_1.appendStep(b_1);
            return c_1;
        }
        if (expression.match(/^[0-9]+$/)) {
            return new expressions_1.NumberExpr(expression);
        }
        var a = new node_tests_1.NodeTestName(expression);
        var b = new expressions_1.StepExpr(axis || tokens_1.xPathAxis.CHILD, a, this);
        var c = new expressions_1.LocationExpr(this);
        c.appendStep(b);
        return c;
    };
    XPath.prototype.makeSimpleExpr2 = function (expr) {
        var steps = expr.split('/');
        var c = new expressions_1.LocationExpr(this);
        for (var i = 0; i < steps.length; ++i) {
            var a = new node_tests_1.NodeTestName(steps[i]);
            var b = new expressions_1.StepExpr(tokens_1.xPathAxis.CHILD, a, this);
            c.appendStep(b);
        }
        return c;
    };
    XPath.prototype.stackToString = function (stack) {
        var ret = '';
        for (var i = 0; i < stack.length; ++i) {
            if (ret) {
                ret += '\n';
            }
            ret += stack[i].tag.label;
        }
        return ret;
    };
    XPath.prototype.xPathCacheLookup = function (expr) {
        return this.xPathParseCache[expr];
    };
    XPath.prototype.xPathCollectDescendants = function (nodeList, node, opt_tagName) {
        if (opt_tagName && node.getElementsByTagName) {
            (0, common_function_1.copyArray)(nodeList, node.getElementsByTagName(opt_tagName));
            return;
        }
        for (var n = node.firstChild; n; n = n.nextSibling) {
            if (n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE) {
                nodeList.push(n);
            }
            this.xPathCollectDescendants(nodeList, n);
        }
    };
    XPath.prototype.xPathCollectDescendantsReverse = function (nodeList, node) {
        for (var n = node.lastChild; n; n = n.previousSibling) {
            nodeList.push(n);
            this.xPathCollectDescendantsReverse(nodeList, n);
        }
    };
    /**
     * Parses and then evaluates the given XPath expression in the given
     * input context.
     * @param select The xPath string.
     * @param context The Expression Context.
     * @returns A Node Value.
     */
    XPath.prototype.xPathEval = function (select, context) {
        var expression = this.xPathParse(select);
        var response = expression.evaluate(context);
        return response;
    };
    /**
     * DGF - extract a tag name suitable for getElementsByTagName
     *
     * @param nodeTest                     the node test
     * @param ignoreNonElementNodesForNTA  if true, the node list returned when
     *                                     evaluating "node()" will not contain
     *                                     non-element nodes. This can boost
     *                                     performance. This is false by default.
     */
    XPath.prototype.xPathExtractTagNameFromNodeTest = function (nodeTest, ignoreNonElementNodesForNTA) {
        if (nodeTest instanceof node_tests_1.NodeTestName) {
            return nodeTest.name;
        }
        if ((ignoreNonElementNodesForNTA && nodeTest instanceof node_tests_1.NodeTestAny) ||
            nodeTest instanceof node_tests_1.NodeTestElementOrAttribute) {
            return '*';
        }
    };
    XPath.prototype.xPathMatchStack = function (stack, pattern) {
        // NOTE(mesch): The stack matches for variable cardinality are
        // greedy but don't do backtracking. This would be an issue only
        // with rules of the form A* A, i.e. with an element with variable
        // cardinality followed by the same element. Since that doesn't
        // occur in the grammar at hand, all matches on the stack are
        // unambiguous.
        var stackLength = stack.length;
        var patternLength = pattern.length;
        var p;
        var s;
        var match = [];
        match.matchLength = 0;
        var ds = 0;
        for (p = patternLength - 1, s = stackLength - 1; p >= 0 && s >= 0; --p, s -= ds) {
            ds = 0;
            var qmatch = [];
            if (pattern[p] == tokens_1.Q_ZERO_OR_MULTIPLE) {
                p -= 1;
                match.push(qmatch);
                while (s - ds >= 0 && stack[s - ds].tag == pattern[p]) {
                    qmatch.push(stack[s - ds]);
                    ds += 1;
                    match.matchLength += 1;
                }
            }
            else if (pattern[p] == tokens_1.Q_ZERO_OR_ONE) {
                p -= 1;
                match.push(qmatch);
                while (s - ds >= 0 && ds < 2 && stack[s - ds].tag == pattern[p]) {
                    qmatch.push(stack[s - ds]);
                    ds += 1;
                    match.matchLength += 1;
                }
            }
            else if (pattern[p] == tokens_1.Q_ONE_OR_MULTIPLE) {
                p -= 1;
                match.push(qmatch);
                if (stack[s].tag == pattern[p]) {
                    while (s - ds >= 0 && stack[s - ds].tag == pattern[p]) {
                        qmatch.push(stack[s - ds]);
                        ds += 1;
                        match.matchLength += 1;
                    }
                }
                else {
                    return [];
                }
            }
            else if (stack[s].tag == pattern[p]) {
                match.push(stack[s]);
                ds += 1;
                match.matchLength += 1;
            }
            else {
                return [];
            }
            (0, util_1.reverseInPlace)(qmatch);
            qmatch.expr = (0, util_1.mapExpr)(qmatch, function (m) { return m.expr; });
        }
        (0, util_1.reverseInPlace)(match);
        if (p === -1) {
            return match;
        }
        return [];
    };
    /**
     * Finds the best rule for the XPath expression provided.
     * @param expression The XPath string expression.
     * @param previous The previous matched XPath rule.
     * @returns The found rule and the corresponding match.
     */
    XPath.prototype.findXPathRuleForExpression = function (expression, previous) {
        var rule = null;
        var match = '';
        for (var i = 0; i < tokens_1.xPathTokenRules.length; ++i) {
            var result = tokens_1.xPathTokenRules[i].re.exec(expression);
            this.lexerCount++;
            if (result !== null && result.length > 0 && result[0].length > 0) {
                rule = tokens_1.xPathTokenRules[i];
                match = result[0];
                break;
            }
        }
        // Special case: allow operator keywords to be element and
        // variable names.
        // NOTE(mesch): The parser resolves conflicts by looking ahead,
        // and this is the only case where we look back to
        // disambiguate. So this is indeed something different, and
        // looking back is usually done in the lexer (via states in the
        // general case, called "start conditions" in flex(1)). Also, the
        // conflict resolution in the parser is not as robust as it could
        // be, so I'd like to keep as much off the parser as possible (all
        // these precedence values should be computed from the grammar
        // rules and possibly associativity declarations, as in bison(1),
        // and not explicitly set.
        if (rule &&
            (rule == tokens_1.TOK_DIV || rule == tokens_1.TOK_MOD || rule == tokens_1.TOK_AND || rule == tokens_1.TOK_OR) &&
            (!previous ||
                previous.tag == tokens_1.TOK_AT ||
                previous.tag == tokens_1.TOK_DSLASH ||
                previous.tag == tokens_1.TOK_SLASH ||
                previous.tag == tokens_1.TOK_AXIS ||
                previous.tag == tokens_1.TOK_DOLLAR)) {
            rule = tokens_1.TOK_QNAME;
        }
        return { rule: rule, match: match };
    };
    /**
     * Initialization for `xPathParse`.
     * @see xPathParse
     */
    XPath.prototype.xPathParseInit = function () {
        if (this.xPathRules.length) {
            return;
        }
        var xPathNonTerminals = [
            xpath_grammar_rules_1.XPathLocationPath,
            xpath_grammar_rules_1.XPathRelativeLocationPath,
            xpath_grammar_rules_1.XPathAbsoluteLocationPath,
            xpath_grammar_rules_1.XPathStep,
            xpath_grammar_rules_1.XPathNodeTest,
            xpath_grammar_rules_1.XPathPredicate,
            xpath_grammar_rules_1.XPathLiteral,
            xpath_grammar_rules_1.XPathExpr,
            xpath_grammar_rules_1.XPathPrimaryExpr,
            xpath_grammar_rules_1.XPathVariableReference,
            xpath_grammar_rules_1.XPathNumber,
            xpath_grammar_rules_1.XPathFunctionCall,
            xpath_grammar_rules_1.XPathArgumentRemainder,
            xpath_grammar_rules_1.XPathPathExpr,
            xpath_grammar_rules_1.XPathUnionExpr,
            xpath_grammar_rules_1.XPathFilterExpr,
            xpath_grammar_rules_1.XPathDigits
        ];
        // Some simple optimizations for the xpath expression parser: sort
        // grammar rules descending by length, so that the longest match is
        // first found.
        this.xPathGrammarRules.sort(function (a, b) {
            var la = a[1].length;
            var lb = b[1].length;
            if (la < lb) {
                return 1;
            }
            else if (la > lb) {
                return -1;
            }
            return 0;
        });
        var k = 1;
        for (var i = 0; i < xPathNonTerminals.length; ++i) {
            xPathNonTerminals[i].key = k++;
        }
        for (var i = 0; i < tokens_1.xPathTokenRules.length; ++i) {
            tokens_1.xPathTokenRules[i].key = k++;
        }
        this.xPathLog("XPath parse INIT: ".concat(k, " rules"));
        // Another slight optimization: sort the rules into bins according
        // to the last element (observing quantifiers), so we can restrict
        // the match against the stack to the subest of rules that match the
        // top of the stack.
        //
        // TODO(mesch): What we actually want is to compute states as in
        // bison, so that we don't have to do any explicit and iterated
        // match against the stack.
        function push_(array, position, element) {
            if (!array[position]) {
                array[position] = [];
            }
            array[position].push(element);
        }
        for (var i = 0; i < this.xPathGrammarRules.length; ++i) {
            var rule = this.xPathGrammarRules[i];
            var pattern = rule[1];
            for (var j = pattern.length - 1; j >= 0; --j) {
                if (pattern[j] == tokens_1.Q_ONE_OR_MULTIPLE) {
                    push_(this.xPathRules, pattern[j - 1].key, rule);
                    break;
                }
                else if (pattern[j] == tokens_1.Q_ZERO_OR_MULTIPLE || pattern[j] == tokens_1.Q_ZERO_OR_ONE) {
                    push_(this.xPathRules, pattern[j - 1].key, rule);
                    --j;
                }
                else {
                    push_(this.xPathRules, pattern[j].key, rule);
                    break;
                }
            }
        }
        this.xPathLog("XPath parse INIT: ".concat(this.xPathRules.length, " rule bins"));
        var sum = 0;
        (0, util_1.mapExec)(this.xPathRules, function (i) {
            if (i) {
                sum += i.length;
            }
        });
        this.xPathLog("XPath parse INIT: ".concat(sum / this.xPathRules.length, " average bin size"));
    };
    /**
     * The entry point for the parser.
     * @param expression a string that contains an XPath expression.
     * @param axis The XPath axis. Used when the match does not start with the parent.
     * @returns an expression object that can be evaluated with an
     * expression context.
     */
    XPath.prototype.xPathParse = function (expression, axis) {
        var originalExpression = "".concat(expression);
        this.xPathLog("parse ".concat(expression));
        this.xPathParseInit();
        // TODO: Removing the cache for now.
        // The cache became a real problem when having to deal with `self-and-siblings`
        // axis.
        /* const cached = this.xPathCacheLookup(expression);
        if (cached && axis === undefined) {
            this.xPathLog(' ... cached');
            return cached;
        } */
        // Optimize for a few common cases: simple attribute node tests
        // (@id), simple element node tests (page), variable references
        // ($address), numbers (4), multi-step path expressions where each
        // step is a plain element node test
        // (page/overlay/locations/location).
        if (expression.match(/^(\$|@)?\w+$/i)) {
            var ret = this.makeSimpleExpr(expression, axis);
            this.xPathParseCache[expression] = ret;
            this.xPathLog(' ... simple');
            return ret;
        }
        if (expression.match(/^\w+(\/\w+)*$/i)) {
            var ret = this.makeSimpleExpr2(expression);
            this.xPathParseCache[expression] = ret;
            this.xPathLog(' ... simple 2');
            return ret;
        }
        var cachekey = expression; // expression is modified during parse
        var stack = [];
        var ahead = null;
        var previous = null;
        var done = false;
        var parseCount = 0;
        this.lexerCount = 0;
        var reduceCount = 0;
        while (!done) {
            parseCount++;
            expression = expression.replace(/^\s*/, '');
            previous = ahead;
            ahead = null;
            var _a = this.findXPathRuleForExpression(expression, previous), rule = _a.rule, match = _a.match;
            if (rule) {
                expression = expression.substr(match.length);
                this.xPathLog("token: ".concat(match, " -- ").concat(rule.label));
                ahead = {
                    tag: rule,
                    match: match,
                    prec: rule.prec ? rule.prec : 0, // || 0 is removed by the compiler
                    expr: this.makeTokenExpr(match)
                };
            }
            else {
                this.xPathLog('DONE');
                done = true;
            }
            while (this.xPathReduce(stack, ahead)) {
                reduceCount++;
                this.xPathLog("stack: ".concat(this.stackToString(stack)));
            }
        }
        this.xPathLog("stack: ".concat(this.stackToString(stack)));
        // DGF any valid XPath should "reduce" to a single Expr token
        if (stack.length !== 1) {
            throw "XPath parse error ".concat(cachekey, ":\n").concat(this.stackToString(stack));
        }
        var result = stack[0].expr;
        // TODO: Remove this `if` after getting to rewrite `xPathReduce`.
        if (axis !== undefined &&
            !result.absolute &&
            !originalExpression.startsWith('*') &&
            result.steps &&
            Array.isArray(result.steps)) {
            result.steps[0].axis = axis;
        }
        this.xPathParseCache[cachekey] = result;
        this.xPathLog("XPath parse: ".concat(parseCount, " / ").concat(this.lexerCount, " / ").concat(reduceCount));
        return result;
    };
    XPath.prototype.findGrammarRuleCandidate = function (ruleset, stack) {
        for (var i = 0; i < ruleset.length; ++i) {
            var rule = ruleset[i];
            var match = this.xPathMatchStack(stack, rule[1]);
            if (match.length) {
                var candidate = {
                    tag: rule[0],
                    rule: rule,
                    match: match,
                    prec: undefined
                };
                candidate.prec = this.xPathGrammarPrecedence(candidate);
                return candidate;
            }
        }
        return null;
    };
    /**
     * DGF xPathReduce is where the magic happens in this parser.
     * Check `src\xpath\xpath-grammar-rules.ts` to find the table of
     * grammatical rules and precedence numbers, "The productions of the grammar".
     *
     * The idea here is that we want to take a stack of tokens and apply
     * grammatical rules to them, "reducing" them to higher-level
     * tokens. Ultimately, any valid XPath should reduce to exactly one
     * "Expr" token.
     *
     * Reduce too early or too late, and you'll have two tokens that can't reduce
     * to single Expr. For example, you may hastily reduce a qname that
     * should name a function, incorrectly treating it as a tag name.
     * Or you may reduce too late, accidentally reducing the last part of the
     * XPath into a top-level "Expr" that won't reduce with earlier parts of
     * the XPath.
     *
     * A "candidate" is a grammatical rule candidate, with a given precedence
     * number. "ahead" is the upcoming token, which also has a precedence
     * number. If the token has a higher precedence number than
     * the rule candidate, we'll "shift" the token onto the token stack,
     * instead of immediately applying the rule candidate.
     *
     * Some tokens have left associativity, in which case we shift when they
     * have LOWER precedence than the candidate.
     * @param stack The actual grammar rule stack.
     * @param ahead The grammar rule ahead.
     * @return `true` if a grammar rule candidate was applied. `false` otherwise.
     * @private
     */
    XPath.prototype.xPathReduce = function (stack, ahead) {
        var candidate = null;
        if (stack.length > 0) {
            var top_1 = stack[stack.length - 1];
            var ruleset = this.xPathRules[top_1.tag.key];
            if (ruleset) {
                candidate = this.findGrammarRuleCandidate(ruleset, stack);
            }
        }
        if (candidate && (!ahead || candidate.prec > ahead.prec || (ahead.tag.left && candidate.prec >= ahead.prec))) {
            for (var i = 0; i < candidate.match.matchLength; ++i) {
                stack.pop();
            }
            this.xPathLog("reduce ".concat(candidate.tag.label, " ").concat(candidate.prec, " ahead ").concat(ahead ? ahead.tag.label + ' ' + ahead.prec + (ahead.tag.left ? ' left' : '') : ' none '));
            var matchExpression = (0, util_1.mapExpr)(candidate.match, function (m) { return m.expr; });
            this.xPathLog("going to apply ".concat(candidate.rule[3]));
            candidate.expr = candidate.rule[3].apply(this, matchExpression);
            stack.push(candidate);
            return true;
        }
        else {
            if (ahead) {
                this.xPathLog("shift ".concat(ahead.tag.label, " ").concat(ahead.prec).concat(ahead.tag.left ? ' left' : '', " over ").concat(candidate ? candidate.tag.label + ' ' + candidate.prec : ' none'));
                stack.push(ahead);
            }
            return false;
        }
    };
    /**
     * Utility function to sort a list of nodes. Used by xsltSort().
     * @param context The Expression Context.
     * @param sort TODO
     */
    XPath.prototype.xPathSort = function (context, sort) {
        if (sort.length === 0) {
            return;
        }
        var sortList = [];
        for (var i = 0; i < context.contextSize(); ++i) {
            var node = context.nodeList[i];
            var sortItem = {
                node: node,
                key: []
            };
            var clonedContext = context.clone([node], undefined, 0, undefined);
            for (var _i = 0, sort_1 = sort; _i < sort_1.length; _i++) {
                var s = sort_1[_i];
                var value = s.expr.evaluate(clonedContext);
                var evalue = void 0;
                if (s.type === 'text') {
                    evalue = value.stringValue();
                }
                else if (s.type === 'number') {
                    evalue = value.numberValue();
                }
                sortItem.key.push({
                    value: evalue,
                    order: s.order
                });
            }
            // Make the sort stable by adding a lowest priority sort by
            // id. This is very convenient and furthermore required by the
            // spec ([XSLT] - Section 10 Sorting).
            sortItem.key.push({
                value: i,
                order: 'ascending'
            });
            sortList.push(sortItem);
        }
        sortList.sort(this.xPathSortByKey);
        var nodes = [];
        for (var i = 0; i < sortList.length; ++i) {
            var node = sortList[i].node;
            node.siblingPosition = i;
            nodes.push(node);
        }
        context.nodeList = nodes;
        context.setNode(0);
    };
    // Sorts by all order criteria defined. According to the JavaScript
    // spec ([ECMA] Section 11.8.5), the compare operators compare strings
    // as strings and numbers as numbers.
    //
    // NOTE: In browsers which do not follow the spec, this breaks only in
    // the case that numbers should be sorted as strings, which is very
    // uncommon.
    XPath.prototype.xPathSortByKey = function (v1, v2) {
        // NOTE: Sort key vectors of different length never occur in
        // xsltSort.
        for (var i = 0; i < v1.key.length; ++i) {
            var o = v1.key[i].order == 'descending' ? -1 : 1;
            if (v1.key[i].value > v2.key[i].value) {
                return +1 * o;
            }
            if (v1.key[i].value < v2.key[i].value) {
                return -1 * o;
            }
        }
        return 0;
    };
    XPath.prototype.xPathStep = function (nodes, steps, step, input, context) {
        var s = steps[step];
        var ctx2 = context.clone([input], undefined, 0, undefined);
        if (context.returnOnFirstMatch && !s.hasPositionalPredicate) {
            var nodeList = s.evaluate(ctx2).nodeSetValue();
            // the predicates were not processed in the last evaluate(), so that we can
            // process them here with the returnOnFirstMatch optimization. We do a
            // depth-first grab at any nodes that pass the predicate tests. There is no
            // way to optimize when predicates contain positional selectors, including
            // indexes or uses of the last() or position() functions, because they
            // typically require the entire nodeList for context. Process without
            // optimization if we encounter such selectors.
            var nLength = nodeList.length;
            var pLength = s.predicate.length;
            nodeListLoop: for (var i = 0; i < nLength; ++i) {
                for (var j = 0; j < pLength; ++j) {
                    if (!s.predicate[j].evaluate(context.clone(nodeList, undefined, i, undefined)).booleanValue()) {
                        continue nodeListLoop;
                    }
                }
                // n survived the predicate tests!
                if (step == steps.length - 1) {
                    nodes.push(nodeList[i]);
                }
                else {
                    this.xPathStep(nodes, steps, step + 1, nodeList[i], context);
                }
                if (nodes.length > 0) {
                    break;
                }
            }
        }
        else {
            // set returnOnFirstMatch to false for the cloned ExprContext, because
            // behavior in StepExpr.prototype.evaluate is driven off its value. Note
            // that the original context may still have true for this value.
            ctx2.returnOnFirstMatch = false;
            var nodeList = s.evaluate(ctx2).nodeSetValue();
            for (var i = 0; i < nodeList.length; ++i) {
                if (step == steps.length - 1) {
                    nodes.push(nodeList[i]);
                }
                else {
                    this.xPathStep(nodes, steps, step + 1, nodeList[i], context);
                }
            }
        }
    };
    XPath.prototype.xPathGrammarPrecedence = function (frame) {
        var ret = 0;
        if (frame.rule) {
            /* normal reduce */
            if (frame.rule.length >= 3 && frame.rule[2] >= 0) {
                ret = frame.rule[2];
            }
            else {
                for (var i = 0; i < frame.rule[1].length; ++i) {
                    var p = this.xPathTokenPrecedence(frame.rule[1][i]);
                    ret = Math.max(ret, p);
                }
            }
        }
        else if (frame.tag) {
            /* TOKEN match */
            ret = this.xPathTokenPrecedence(frame.tag);
        }
        else if (frame.length) {
            /* Q_ match */
            for (var j = 0; j < frame.length; ++j) {
                var p = this.xPathGrammarPrecedence(frame[j]);
                ret = Math.max(ret, p);
            }
        }
        return ret;
    };
    XPath.prototype.xPathTokenPrecedence = function (tag) {
        return tag.prec || 2;
    };
    return XPath;
}());
exports.XPath = XPath;
//# sourceMappingURL=xpath.js.map