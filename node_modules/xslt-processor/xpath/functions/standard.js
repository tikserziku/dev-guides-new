"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.boolean = boolean;
exports.ceiling = ceiling;
exports.concat = concat;
exports.contains = contains;
exports.count = count;
exports.current = current;
exports.endsWith = endsWith;
exports._false = _false;
exports.formatNumber = formatNumber;
exports.floor = floor;
exports.generateId = generateId;
exports.id = id;
exports.lang = lang;
exports.last = last;
exports.localName = localName;
exports.matches = matches;
exports._name = _name;
exports.namespaceUri = namespaceUri;
exports.normalizeSpace = normalizeSpace;
exports.not = not;
exports.number = number;
exports.position = position;
exports.round = round;
exports.startsWith = startsWith;
exports._string = _string;
exports.stringLength = stringLength;
exports.substring = substring;
exports.substringAfter = substringAfter;
exports.substringBefore = substringBefore;
exports.sum = sum;
exports.translate = translate;
exports._true = _true;
exports.xmlToJson = xmlToJson;
var dom_1 = require("../../dom");
var values_1 = require("../values");
var internal_functions_1 = require("./internal-functions");
/* Support functions. They are not exported. */
function cyrb53(str, seed) {
    if (seed === void 0) { seed = 0; }
    var h1 = 0xdeadbeef ^ seed;
    var h2 = 0x41c6ce57 ^ seed;
    for (var i = 0, ch = void 0; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
    h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
    h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
}
// Exported functions.
// In theory none of the `this.args` should work here,
// but `this` is replaced on `FunctionCallExpr.evaluate()`
// executes.
function boolean(context) {
    (0, internal_functions_1.assert)(this.args.length === 1);
    return new values_1.BooleanValue(this.args[0].evaluate(context).booleanValue());
}
function ceiling(context) {
    (0, internal_functions_1.assert)(this.args.length === 1);
    var num = this.args[0].evaluate(context).numberValue();
    return new values_1.NumberValue(Math.ceil(num));
}
function concat(context) {
    var ret = '';
    for (var i = 0; i < this.args.length; ++i) {
        ret += this.args[i].evaluate(context).stringValue();
    }
    return new values_1.StringValue(ret);
}
function contains(context) {
    (0, internal_functions_1.assert)(this.args.length === 2);
    var s0 = this.args[0].evaluate(context).stringValue();
    var s1 = this.args[1].evaluate(context).stringValue();
    return new values_1.BooleanValue(s0.includes(s1));
}
function count(context) {
    (0, internal_functions_1.assert)(this.args.length === 1);
    var v = this.args[0].evaluate(context);
    return new values_1.NumberValue(v.nodeSetValue().length);
}
function current(context) {
    (0, internal_functions_1.assert)(this.args.length === 0);
    return new values_1.NodeSetValue([context.nodeList[context.position]]);
}
function endsWith(context) {
    (0, internal_functions_1.assert)(this.args.length === 2);
    var s0 = this.args[0].evaluate(context).stringValue();
    var s1 = this.args[1].evaluate(context).stringValue();
    var re = new RegExp("".concat((0, internal_functions_1.regExpEscape)(s1), "$"));
    return new values_1.BooleanValue(re.test(s0));
}
function _false() {
    (0, internal_functions_1.assert)(this.args.length === 0);
    return new values_1.BooleanValue(false);
}
/**
 * Formats the integer part of a number. Used by `formatNumber`.
 * @param _number The integer part of the number.
 * @param _mask The mask provided.
 * @returns The formatted integer part of the number as a string.
 */
function formatNumberIntegerPart(_number, _mask, settings) {
    var formattedIntegerPart = "";
    var lastMaskPlaceholder = "";
    var numberPosition = _number.length - 1;
    for (var i = _mask.length - 1; i >= 0; i--) {
        lastMaskPlaceholder = _mask[i];
        switch (lastMaskPlaceholder) {
            case '#':
                formattedIntegerPart = _number[numberPosition] + formattedIntegerPart;
                numberPosition--;
                break;
            case '0':
                formattedIntegerPart = _number[numberPosition] + formattedIntegerPart;
                numberPosition--;
                break;
            case ',':
                formattedIntegerPart = settings.groupingSeparator + formattedIntegerPart;
                break;
        }
    }
    for (; numberPosition >= 0; numberPosition--) {
        formattedIntegerPart = _number[numberPosition] + formattedIntegerPart;
    }
    return formattedIntegerPart;
}
/**
 * Formats the decimal part of a number. Used by `formatNumber`.
 * @param _number The decimal part of the number.
 * @param _mask The mask provided.
 * @returns The formatted decimal part of the number as a string.
 */
function formatNumberDecimalPart(_number, _mask, settings) {
    var formattedDecimalPart = "";
    // eslint-disable-next-line no-unused-vars
    var _settings = settings;
    if (_mask === null || _mask === undefined) {
        return formattedDecimalPart;
    }
    var i = 0;
    for (; i < _mask.length; i++) {
        switch (_mask[i]) {
            case '#':
                formattedDecimalPart += _number[i];
                break;
            case '0':
                if (i >= _number.length) {
                    formattedDecimalPart += '0';
                }
                else {
                    formattedDecimalPart += _number[i];
                }
                break;
        }
    }
    return formattedDecimalPart;
}
/**
 * XPath `format-number` function implementation.
 * @param context The Expression Context.
 * @returns A formatted number as string.
 */
function formatNumber(context) {
    (0, internal_functions_1.assert)(this.args.length >= 2 && this.args.length < 4);
    var firstArgument = this.args[0].evaluate(context).stringValue();
    var secondArgument = this.args[1].evaluate(context).stringValue();
    var numberTest = parseFloat(firstArgument);
    if (isNaN(numberTest)) {
        return new values_1.StringValue(context.decimalFormatSettings.naN);
    }
    var numberParts = String(numberTest).split('.');
    var maskParts = secondArgument.split('.');
    switch (numberParts.length) {
        case 1: // Integer
            return new values_1.StringValue(formatNumberIntegerPart(numberParts[0], maskParts[0], context.decimalFormatSettings));
        case 2: // Decimal
            var decimalPart = formatNumberDecimalPart(numberParts[1], maskParts.length === 2 ? maskParts[1] : undefined, context.decimalFormatSettings);
            if (decimalPart.length === 0) {
                return new values_1.StringValue(formatNumberIntegerPart(numberParts[0], maskParts[0], context.decimalFormatSettings));
            }
            return new values_1.StringValue(formatNumberIntegerPart(numberParts[0], maskParts[0], context.decimalFormatSettings) +
                context.decimalFormatSettings.decimalSeparator +
                decimalPart);
    }
}
function floor(context) {
    (0, internal_functions_1.assert)(this.args.length === 1);
    var num = this.args[0].evaluate(context).numberValue();
    return new values_1.NumberValue(Math.floor(num));
}
function generateId(context) {
    return new values_1.StringValue('A' + cyrb53(JSON.stringify(context.nodeList[context.position].id)));
}
function id(context) {
    (0, internal_functions_1.assert)(this.args.length === 1);
    var e = this.args[0].evaluate(context);
    var ret = [];
    var ids;
    if (e.type == 'node-set') {
        ids = [];
        var en = e.nodeSetValue();
        for (var i = 0; i < en.length; ++i) {
            var v = (0, dom_1.xmlValue)(en[i]).split(/\s+/);
            for (var ii = 0; ii < v.length; ++ii) {
                ids.push(v[ii]);
            }
        }
    }
    else {
        ids = e.stringValue().split(/\s+/);
    }
    var d = context.root;
    for (var i = 0; i < ids.length; ++i) {
        var n = d.getElementById(ids[i]);
        if (n) {
            ret.push(n);
        }
    }
    return new values_1.NodeSetValue(ret);
}
function lang(context) {
    (0, internal_functions_1.assert)(this.args.length === 1);
    var lang = this.args[0].evaluate(context).stringValue();
    var xmlLang;
    var n = context.nodeList[context.position];
    while (n && n != n.parentNode /* just in case ... */) {
        xmlLang = n.getAttributeValue('xml:lang');
        if (xmlLang) {
            break;
        }
        n = n.parentNode;
    }
    if (!xmlLang) {
        return new values_1.BooleanValue(false);
    }
    var re = new RegExp("^".concat(lang, "$"), 'i');
    return new values_1.BooleanValue(xmlLang.match(re) || xmlLang.replace(/_.*$/, '').match(re));
}
function last(context) {
    (0, internal_functions_1.assert)(this.args.length === 0);
    // NOTE(mesch): XPath position starts at 1.
    return new values_1.NumberValue(context.contextSize());
}
function localName(context) {
    (0, internal_functions_1.assert)(this.args.length === 1 || this.args.length === 0);
    var n;
    if (this.args.length == 0) {
        n = [context.nodeList[context.position]];
    }
    else {
        n = this.args[0].evaluate(context).nodeSetValue();
    }
    if (n.length === 0) {
        return new values_1.StringValue('');
    }
    return new values_1.StringValue(n[0].localName);
}
function matches(context) {
    (0, internal_functions_1.assert)(this.args.length >= 2);
    var s0 = this.args[0].evaluate(context).stringValue();
    var s1 = this.args[1].evaluate(context).stringValue();
    var s2;
    if (this.args.length > 2) {
        s2 = this.args[2].evaluate(context).stringValue();
        if (/[^mi]/.test(s2)) {
            throw new Error("Invalid regular expression syntax: ".concat(s2));
        }
    }
    var re;
    try {
        re = new RegExp(s1, s2);
    }
    catch (e) {
        throw new Error("Invalid matches argument: ".concat(s1));
    }
    return new values_1.BooleanValue(re.test(s0));
}
function _name(context) {
    (0, internal_functions_1.assert)(this.args.length === 1 || this.args.length === 0);
    var n;
    if (this.args.length === 0) {
        n = [context.nodeList[context.position]];
    }
    else {
        n = this.args[0].evaluate(context).nodeSetValue();
    }
    if (n.length === 0) {
        return new values_1.StringValue('');
    }
    return new values_1.StringValue(n[0].nodeName);
}
function namespaceUri(context) {
    (0, internal_functions_1.assert)(this.args.length === 1 || this.args.length === 0);
    var nodes;
    if (this.args.length === 0) {
        nodes = [context.nodeList[context.position]];
    }
    else {
        nodes = this.args[0].evaluate(context).nodeSetValue();
    }
    if (nodes.length === 0) {
        return new values_1.StringValue('');
    }
    return new values_1.StringValue(nodes[0].namespaceUri || '');
}
function normalizeSpace(context) {
    var s;
    if (this.args.length > 0) {
        s = this.args[0].evaluate(context).stringValue();
    }
    else {
        s = new values_1.NodeSetValue([context.nodeList[context.position]]).stringValue();
    }
    s = s.replace(/^\s*/, '').replace(/\s*$/, '').replace(/\s+/g, ' ');
    return new values_1.StringValue(s);
}
function not(context) {
    (0, internal_functions_1.assert)(this.args.length === 1);
    var ret = !this.args[0].evaluate(context).booleanValue();
    return new values_1.BooleanValue(ret);
}
function number(context) {
    (0, internal_functions_1.assert)(this.args.length === 1 || this.args.length === 0);
    if (this.args.length === 1) {
        return new values_1.NumberValue(this.args[0].evaluate(context).numberValue());
    }
    return new values_1.NumberValue(new values_1.NodeSetValue([context.nodeList[context.position]]).numberValue());
}
function position(context) {
    (0, internal_functions_1.assert)(this.args.length === 0);
    // NOTE(mesch): XPath position starts at 1.
    return new values_1.NumberValue(context.position + 1);
}
function round(context) {
    (0, internal_functions_1.assert)(this.args.length === 1);
    var num = this.args[0].evaluate(context).numberValue();
    return new values_1.NumberValue(Math.round(num));
}
function startsWith(context) {
    (0, internal_functions_1.assert)(this.args.length == 2);
    var s0 = this.args[0].evaluate(context).stringValue();
    var s1 = this.args[1].evaluate(context).stringValue();
    return new values_1.BooleanValue(s0.indexOf(s1) === 0);
}
function _string(context) {
    (0, internal_functions_1.assert)(this.args.length === 1 || this.args.length === 0);
    if (this.args.length === 0) {
        return new values_1.StringValue(new values_1.NodeSetValue([context.nodeList[context.position]]).stringValue());
    }
    return new values_1.StringValue(this.args[0].evaluate(context).stringValue());
}
function stringLength(context) {
    var s;
    if (this.args.length > 0) {
        s = this.args[0].evaluate(context).stringValue();
    }
    else {
        s = new values_1.NodeSetValue([context.nodeList[context.position]]).stringValue();
    }
    return new values_1.NumberValue(s.length);
}
function substring(context) {
    // NOTE: XPath defines the position of the first character in a
    // string to be 1, in JavaScript this is 0 ([XPATH] Section 4.2).
    (0, internal_functions_1.assert)(this.args.length === 2 || this.args.length === 3);
    var s0 = this.args[0].evaluate(context).stringValue();
    var s1 = this.args[1].evaluate(context).numberValue();
    var ret;
    if (this.args.length === 2) {
        var i1 = Math.max(0, Math.round(s1) - 1);
        ret = s0.substr(i1);
    }
    else {
        var s2 = this.args[2].evaluate(context).numberValue();
        var i0 = Math.round(s1) - 1;
        var i1 = Math.max(0, i0);
        var i2 = Math.round(s2) - Math.max(0, -i0);
        ret = s0.substr(i1, i2);
    }
    return new values_1.StringValue(ret);
}
function substringAfter(context) {
    (0, internal_functions_1.assert)(this.args.length === 2);
    var s0 = this.args[0].evaluate(context).stringValue();
    var s1 = this.args[1].evaluate(context).stringValue();
    var i = s0.indexOf(s1);
    var ret;
    if (i === -1) {
        ret = '';
    }
    else {
        ret = s0.substr(i + s1.length);
    }
    return new values_1.StringValue(ret);
}
function substringBefore(context) {
    (0, internal_functions_1.assert)(this.args.length === 2);
    var s0 = this.args[0].evaluate(context).stringValue();
    var s1 = this.args[1].evaluate(context).stringValue();
    var i = s0.indexOf(s1);
    var ret;
    if (i === -1) {
        ret = '';
    }
    else {
        ret = s0.substr(0, i);
    }
    return new values_1.StringValue(ret);
}
function sum(context) {
    (0, internal_functions_1.assert)(this.args.length === 1);
    var n = this.args[0].evaluate(context).nodeSetValue();
    var sum = 0;
    for (var i = 0; i < n.length; ++i) {
        sum += parseInt((0, dom_1.xmlValue)(n[i])) - 0;
    }
    return new values_1.NumberValue(sum);
}
function translate(context) {
    (0, internal_functions_1.assert)(this.args.length === 3);
    var s0 = this.args[0].evaluate(context).stringValue();
    var s1 = this.args[1].evaluate(context).stringValue();
    var s2 = this.args[2].evaluate(context).stringValue();
    for (var i = 0; i < s1.length; ++i) {
        s0 = s0.replace(new RegExp(s1.charAt(i), 'g'), s2.charAt(i));
    }
    return new values_1.StringValue(s0);
}
function _true() {
    (0, internal_functions_1.assert)(this.args.length === 0);
    return new values_1.BooleanValue(true);
}
function xmlToJson(context) {
    (0, internal_functions_1.assert)(this.args.length < 2);
    return new values_1.StringValue(JSON.stringify(!this.args.length ? 'null' : (0, dom_1.xmlValue)(context.nodeList[context.position])));
}
//# sourceMappingURL=standard.js.map