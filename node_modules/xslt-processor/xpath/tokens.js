"use strict";
// The tokens of the language. The label property is just used for
// generating debug output. The prec property is the precedence used
// for shift/reduce resolution. Default precedence is 0 as a lookahead
// token and 2 on the stack. TODO(mesch): this is certainly not
// necessary and too complicated. Simplify this!
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASSOC_LEFT = exports.Q_ONE_OR_MULTIPLE = exports.Q_ZERO_OR_MULTIPLE = exports.Q_ZERO_OR_ONE = exports.xPathTokenRules = exports.TOK_NODEO = exports.TOK_QNAME = exports.TOK_NUMBER = exports.TOK_LITERALQQ = exports.TOK_LITERALQ = exports.TOK_ASTERISK = exports.TOK_NCNAME = exports.TOK_DOLLAR = exports.TOK_BRACKC = exports.TOK_BRACKO = exports.TOK_MOD = exports.TOK_DIV = exports.TOK_MINUS = exports.TOK_PLUS = exports.TOK_LT = exports.TOK_LE = exports.TOK_GT = exports.TOK_GE = exports.TOK_NEQ = exports.TOK_EQ = exports.TOK_AND = exports.TOK_OR = exports.TOK_COMMA = exports.TOK_AT = exports.TOK_DOT = exports.TOK_DDOT = exports.TOK_PARENC = exports.TOK_PARENO = exports.TOK_AXISNAME = exports.TOK_COLON = exports.TOK_AXIS = exports.TOK_SLASH = exports.TOK_DSLASH = exports.TOK_PIPE = exports.xPathAxis = void 0;
var xmltoken_1 = require("../dom/xmltoken");
// NOTE: tabular formatting is the big exception, but here it should
// be OK.
// The axes of XPath expressions.
exports.xPathAxis = {
    ANCESTOR_OR_SELF: 'ancestor-or-self',
    ANCESTOR: 'ancestor',
    ATTRIBUTE: 'attribute',
    CHILD: 'child',
    DESCENDANT_OR_SELF: 'descendant-or-self',
    DESCENDANT: 'descendant',
    FOLLOWING_SIBLING: 'following-sibling',
    FOLLOWING: 'following',
    NAMESPACE: 'namespace',
    PARENT: 'parent',
    PRECEDING_SIBLING: 'preceding-sibling',
    PRECEDING: 'preceding',
    SELF: 'self',
    SELF_AND_SIBLINGS: 'self-and-siblings' // Doesn't exist officially.
    // It is here for a special case of `<xsl:apply-templates>`.
};
var xpathAxesRe = [
    exports.xPathAxis.ANCESTOR_OR_SELF,
    exports.xPathAxis.ANCESTOR,
    exports.xPathAxis.ATTRIBUTE,
    exports.xPathAxis.CHILD,
    exports.xPathAxis.DESCENDANT_OR_SELF,
    exports.xPathAxis.DESCENDANT,
    exports.xPathAxis.FOLLOWING_SIBLING,
    exports.xPathAxis.FOLLOWING,
    exports.xPathAxis.NAMESPACE,
    exports.xPathAxis.PARENT,
    exports.xPathAxis.PRECEDING_SIBLING,
    exports.xPathAxis.PRECEDING,
    exports.xPathAxis.SELF
].join('(?=::)|') + '(?=::)'; //(viat) bodgy fix because namespace-uri() was getting detected as the namespace axis. maybe less bodgy fix later.
exports.TOK_PIPE = {
    label: '|',
    prec: 17,
    re: new RegExp('^\\|'),
    key: undefined
};
exports.TOK_DSLASH = {
    label: '//',
    prec: 19,
    re: new RegExp('^//'),
    key: undefined
};
exports.TOK_SLASH = {
    label: '/',
    prec: 30,
    re: new RegExp('^/'),
    key: undefined
};
exports.TOK_AXIS = {
    label: '::',
    prec: 20,
    re: new RegExp('^::'),
    key: undefined
};
exports.TOK_COLON = {
    label: ':',
    prec: 1000,
    re: new RegExp('^:'),
    key: undefined
};
exports.TOK_AXISNAME = {
    label: '[axis]',
    re: new RegExp("^(".concat(xpathAxesRe, ")")),
    key: undefined
};
exports.TOK_PARENO = {
    label: '(',
    prec: 34,
    re: new RegExp('^\\('),
    key: undefined
};
exports.TOK_PARENC = {
    label: ')',
    re: new RegExp('^\\)'),
    key: undefined
};
exports.TOK_DDOT = {
    label: '..',
    prec: 34,
    re: new RegExp('^\\.\\.'),
    key: undefined
};
exports.TOK_DOT = {
    label: '.',
    prec: 34,
    re: new RegExp('^\\.'),
    key: undefined
};
exports.TOK_AT = {
    label: '@',
    prec: 34,
    re: new RegExp('^@'),
    key: undefined
};
exports.TOK_COMMA = {
    label: ',',
    re: new RegExp('^,'),
    key: undefined
};
exports.TOK_OR = {
    label: 'or',
    prec: 10,
    re: new RegExp('^or\\b'),
    key: undefined
};
exports.TOK_AND = {
    label: 'and',
    prec: 11,
    re: new RegExp('^and\\b'),
    key: undefined
};
exports.TOK_EQ = {
    label: '=',
    prec: 12,
    re: new RegExp('^='),
    key: undefined
};
exports.TOK_NEQ = {
    label: '!=',
    prec: 12,
    re: new RegExp('^!='),
    key: undefined
};
exports.TOK_GE = {
    label: '>=',
    prec: 13,
    re: new RegExp('^>='),
    key: undefined
};
exports.TOK_GT = {
    label: '>',
    prec: 13,
    re: new RegExp('^>'),
    key: undefined
};
exports.TOK_LE = {
    label: '<=',
    prec: 13,
    re: new RegExp('^<='),
    key: undefined
};
exports.TOK_LT = {
    label: '<',
    prec: 13,
    re: new RegExp('^<'),
    key: undefined
};
exports.TOK_PLUS = {
    label: '+',
    prec: 14,
    re: new RegExp('^\\+'),
    left: true,
    key: undefined
};
exports.TOK_MINUS = {
    label: '-',
    prec: 14,
    re: new RegExp('^\\-'),
    left: true,
    key: undefined
};
exports.TOK_DIV = {
    label: 'div',
    prec: 15,
    re: new RegExp('^div\\b'),
    left: true,
    key: undefined
};
exports.TOK_MOD = {
    label: 'mod',
    prec: 15,
    re: new RegExp('^mod\\b'),
    left: true,
    key: undefined
};
exports.TOK_BRACKO = {
    label: '[',
    prec: 32,
    re: new RegExp('^\\['),
    key: undefined
};
exports.TOK_BRACKC = {
    label: ']',
    re: new RegExp('^\\]'),
    key: undefined
};
exports.TOK_DOLLAR = {
    label: '$',
    re: new RegExp('^\\$'),
    key: undefined
};
exports.TOK_NCNAME = {
    label: '[ncname]',
    re: new RegExp("^".concat(xmltoken_1.XML_NC_NAME)),
    key: undefined
};
exports.TOK_ASTERISK = {
    label: '*',
    prec: 15,
    re: new RegExp('^\\*'),
    left: true,
    key: undefined
};
exports.TOK_LITERALQ = {
    label: '[litq]',
    prec: 20,
    re: new RegExp("^'[^\\']*'"),
    key: undefined
};
exports.TOK_LITERALQQ = {
    label: '[litqq]',
    prec: 20,
    re: new RegExp('^"[^\\"]*"'),
    key: undefined
};
exports.TOK_NUMBER = {
    label: '[number]',
    prec: 35,
    re: new RegExp('^\\d+(\\.\\d*)?'),
    key: undefined
};
exports.TOK_QNAME = {
    label: '[qname]',
    re: new RegExp("^(".concat(xmltoken_1.XML_NC_NAME, ":)?").concat(xmltoken_1.XML_NC_NAME)),
    key: undefined
};
exports.TOK_NODEO = {
    label: '[nodeTest-start]',
    re: new RegExp('^(processing-instruction|comment|text|node)\\('),
    key: undefined
};
// The table of the tokens of our grammar, used by the lexer: first
// column the tag, second column a regexp to recognize it in the
// input, third column the precedence of the token, fourth column a
// factory function for the semantic value of the token.
//
// NOTE: order of this list is important, because the first match
// counts. Cf. DDOT and DOT, and AXIS and COLON.
exports.xPathTokenRules = [
    exports.TOK_DSLASH,
    exports.TOK_SLASH,
    exports.TOK_DDOT,
    exports.TOK_DOT,
    exports.TOK_AXIS,
    exports.TOK_COLON,
    exports.TOK_AXISNAME,
    exports.TOK_NODEO,
    exports.TOK_PARENO,
    exports.TOK_PARENC,
    exports.TOK_BRACKO,
    exports.TOK_BRACKC,
    exports.TOK_AT,
    exports.TOK_COMMA,
    exports.TOK_OR,
    exports.TOK_AND,
    exports.TOK_NEQ,
    exports.TOK_EQ,
    exports.TOK_GE,
    exports.TOK_GT,
    exports.TOK_LE,
    exports.TOK_LT,
    exports.TOK_PLUS,
    exports.TOK_MINUS,
    exports.TOK_ASTERISK,
    exports.TOK_PIPE,
    exports.TOK_MOD,
    exports.TOK_DIV,
    exports.TOK_LITERALQ,
    exports.TOK_LITERALQQ,
    exports.TOK_NUMBER,
    exports.TOK_QNAME,
    exports.TOK_NCNAME,
    exports.TOK_DOLLAR
];
// Quantifiers that are used in the productions of the grammar.
exports.Q_ZERO_OR_ONE = {
    label: '?'
};
exports.Q_ZERO_OR_MULTIPLE = {
    label: '*'
};
exports.Q_ONE_OR_MULTIPLE = {
    label: '+'
};
// Tag for left associativity (right assoc is implied by undefined).
exports.ASSOC_LEFT = true;
//# sourceMappingURL=tokens.js.map