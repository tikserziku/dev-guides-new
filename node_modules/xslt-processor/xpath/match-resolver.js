"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatchResolver = void 0;
var expressions_1 = require("./expressions");
/**
 * Class that resolves XPath expressions, returning nodes.
 */
var MatchResolver = /** @class */ (function () {
    function MatchResolver() {
    }
    /**
     * This class entry point.
     * @param expression The expression to be resolved.
     * @param context The Expression Context
     * @returns An array of nodes.
     */
    MatchResolver.prototype.expressionMatch = function (expression, context) {
        if (expression instanceof expressions_1.LocationExpr) {
            return this.locationExpressionMatch(expression, context);
        }
        if (expression instanceof expressions_1.UnionExpr) {
            return this.unionExpressionMatch(expression, context);
        }
        // TODO: Other expressions
        return [];
    };
    /**
     * Resolves a `LocationExpr`.
     * @param expression The Location Expression.
     * @param context The Expression Context.
     * @returns Either the results of a relative resolution, or the results of an
     *          absolute resolution.
     */
    MatchResolver.prototype.locationExpressionMatch = function (expression, context) {
        if (expression === undefined || expression.steps === undefined || expression.steps.length <= 0) {
            throw new Error('Error resolving XSLT match: Location Expression should have steps.');
        }
        if (expression.absolute) {
            // If expression is absolute and the axis of first step is self,
            // the match starts by the #document node (for instance, `<xsl:template match="/">`).
            // Otherwise (axis === 'child'), the match starts on the first
            // child of #document node.
            var firstStep = expression.steps[0];
            if (firstStep.axis === 'self') {
                return this.absoluteXsltMatchByDocumentNode(expression, context);
            }
            return this.absoluteXsltMatch(expression, context);
        }
        return this.relativeXsltMatch(expression, context);
    };
    /**
     * Resolves a `UnionExpr`.
     * @param expression The Union Expression.
     * @param context The Expression Context.
     * @returns The concatenated result of evaluating the both sides of the expression.
     */
    MatchResolver.prototype.unionExpressionMatch = function (expression, context) {
        var expr1Nodes = this.expressionMatch(expression.expr1, context);
        return expr1Nodes.concat(this.expressionMatch(expression.expr2, context));
    };
    /**
     * Finds all the nodes through absolute XPath search, starting on
     * the #document parent node.
     * @param expression The Expression.
     * @param context The Expression Context.
     * @returns The list of found nodes.
     */
    MatchResolver.prototype.absoluteXsltMatchByDocumentNode = function (expression, context) {
        var clonedContext = context.clone([context.root], undefined, 0, undefined);
        var matchedNodes = expression.evaluate(clonedContext).nodeSetValue();
        var finalList = [];
        for (var _i = 0, matchedNodes_1 = matchedNodes; _i < matchedNodes_1.length; _i++) {
            var element = matchedNodes_1[_i];
            if (element.id === context.nodeList[context.position].id) {
                finalList.push(element);
                continue;
            }
        }
        return finalList;
    };
    /**
     * Finds all the nodes through absolute xPath search, starting with the
     * first child of the #document node.
     * @param expression The Expression.
     * @param context The Expression Context.
     * @returns The list of found nodes.
     */
    MatchResolver.prototype.absoluteXsltMatch = function (expression, context) {
        var firstChildOfRoot = context.root.childNodes.find(function (c) { return c.nodeName !== '#dtd-section'; });
        var clonedContext = context.clone([firstChildOfRoot], undefined, 0, undefined);
        var matchedNodes = expression.evaluate(clonedContext).nodeSetValue();
        var finalList = [];
        // If the context is pointing to #document node, it's child node is
        // considered.
        var nodeList;
        if (context.nodeList.length === 1 && context.nodeList[0].nodeName === '#document') {
            nodeList = [context.nodeList[0].childNodes.find(function (c) { return c.nodeName !== '#dtd-section'; })];
        }
        else {
            nodeList = context.nodeList;
        }
        for (var _i = 0, matchedNodes_2 = matchedNodes; _i < matchedNodes_2.length; _i++) {
            var element = matchedNodes_2[_i];
            if (element.id === nodeList[context.position].id) {
                finalList.push(element);
                continue;
            }
        }
        return finalList;
    };
    /**
     * Tries to find relative nodes from the actual context position.
     * If found nodes are already in the context, or if they are children of
     * nodes in the context, they are returned.
     * @param expression The expression used.
     * @param context The Expression Context.
     * @returns The list of found nodes.
     */
    MatchResolver.prototype.relativeXsltMatch = function (expression, context) {
        // For some reason, XPath understands a default as 'child axis'.
        // There's no "self + siblings" axis, so what is expected at this point
        // is to have in the expression context the parent that should
        // have the nodes we are interested in.
        var clonedContext = context.clone();
        var nodes = expression.evaluate(clonedContext).nodeSetValue();
        if (nodes.length === 1 && nodes[0].nodeName === '#document') {
            // As we don't work with the #document node directly, this part
            // returns its first sibling.
            // By the way, it should be *always* one sibling here.
            return [nodes[0].childNodes[0]];
        }
        return nodes;
    };
    return MatchResolver;
}());
exports.MatchResolver = MatchResolver;
//# sourceMappingURL=match-resolver.js.map