"use strict";
// Copyright 2023-2024 Design Liquido
// Copyright 2018 Johannes Wilm
// Copyright 2005 Google Inc.
// All Rights Reserved
//
// Original author: Steffen Meschkat <mesch@google.com>
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xslt = void 0;
var dom_1 = require("../dom");
var xpath_1 = require("../xpath");
var constants_1 = require("../constants");
var values_1 = require("../xpath/values");
var match_resolver_1 = require("../xpath/match-resolver");
/**
 * The main class for XSL-T processing. The implementation is NOT
 * complete; some xsl element are left out.
 *
 * References:
 *
 * [XSLT] XSL-T Specification
 * <http://www.w3.org/TR/1999/REC-xslt-19991116>.
 *
 * [ECMA] ECMAScript Language Specification
 * <http://www.ecma-international.org/publications/standards/Ecma-262.htm>.
 *
 * The XSL processor API has one entry point, the function
 * `xsltProcess()`. It receives as arguments the starting point in the
 * input document as an XPath expression context, the DOM root node of
 * the XSL-T stylesheet, and a DOM node that receives the output.
 *
 * NOTE: Actually, XSL-T processing according to the specification is
 * defined as operation on text documents, not as operation on DOM
 * trees. So, strictly speaking, this implementation is not an XSL-T
 * processor, but the processing engine that needs to be complemented
 * by an XML parser and serializer in order to be complete. Those two
 * are found in the `dom` folder.
 */
var Xslt = /** @class */ (function () {
    function Xslt(options) {
        if (options === void 0) { options = {
            cData: true,
            escape: true,
            selfClosingTags: true,
            parameters: []
        }; }
        this.xPath = new xpath_1.XPath();
        this.xmlParser = new dom_1.XmlParser();
        this.matchResolver = new match_resolver_1.MatchResolver();
        this.options = {
            cData: options.cData === true,
            escape: options.escape === true,
            selfClosingTags: options.selfClosingTags === true,
            parameters: options.parameters || []
        };
        this.outputMethod = 'xml';
        this.outputOmitXmlDeclaration = 'no';
        this.decimalFormatSettings = {
            decimalSeparator: '.',
            groupingSeparator: ',',
            infinity: 'Infinity',
            minusSign: '-',
            naN: 'NaN',
            percent: '%',
            perMille: 'â€°',
            zeroDigit: '0',
            digit: '#',
            patternSeparator: ';'
        };
        this.firstTemplateRan = false;
    }
    /**
     * The exported entry point of the XSL-T processor.
     * @param xmlDoc The input document root, as DOM node.
     * @param stylesheet The stylesheet document root, as DOM node.
     * @returns the processed document, as XML text in a string.
     */
    Xslt.prototype.xsltProcess = function (xmlDoc, stylesheet) {
        return __awaiter(this, void 0, void 0, function () {
            var outputDocument, expressionContext, _i, _a, parameter, transformedOutputXml;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        outputDocument = new dom_1.XDocument();
                        this.outputDocument = outputDocument;
                        expressionContext = new xpath_1.ExprContext([xmlDoc], [outputDocument]);
                        if (this.options.parameters.length > 0) {
                            for (_i = 0, _a = this.options.parameters; _i < _a.length; _i++) {
                                parameter = _a[_i];
                                expressionContext.setVariable(parameter.name, new values_1.StringValue(parameter.value));
                            }
                        }
                        return [4 /*yield*/, this.xsltProcessContext(expressionContext, stylesheet, this.outputDocument)];
                    case 1:
                        _b.sent();
                        transformedOutputXml = (0, dom_1.xmlTransformedText)(outputDocument, {
                            cData: this.options.cData,
                            escape: this.options.escape,
                            selfClosingTags: this.options.selfClosingTags,
                            outputMethod: this.outputMethod
                        });
                        return [2 /*return*/, transformedOutputXml];
                }
            });
        });
    };
    /**
     * The main entry point of the XSL-T processor, as explained on the top of the file.
     * @param context The input document root, as XPath `ExprContext`.
     * @param template The stylesheet document root, as DOM node.
     * @param output If set, the output where the transformation should occur.
     */
    Xslt.prototype.xsltProcessContext = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var node, select, value, nodes, _a, destinationCopyNode, destinationNode, i, node_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!!this.isXsltElement(template)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.xsltPassThrough(context, template, output)];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 2:
                        node = void 0, select = void 0, value = void 0, nodes = void 0;
                        _a = template.localName;
                        switch (_a) {
                            case 'apply-imports': return [3 /*break*/, 3];
                            case 'apply-templates': return [3 /*break*/, 4];
                            case 'attribute': return [3 /*break*/, 6];
                            case 'attribute-set': return [3 /*break*/, 8];
                            case 'call-template': return [3 /*break*/, 9];
                            case 'choose': return [3 /*break*/, 11];
                            case 'comment': return [3 /*break*/, 13];
                            case 'copy': return [3 /*break*/, 15];
                            case 'copy-of': return [3 /*break*/, 18];
                            case 'decimal-format': return [3 /*break*/, 19];
                            case 'element': return [3 /*break*/, 20];
                            case 'fallback': return [3 /*break*/, 22];
                            case 'for-each': return [3 /*break*/, 23];
                            case 'if': return [3 /*break*/, 25];
                            case 'import': return [3 /*break*/, 27];
                            case 'include': return [3 /*break*/, 29];
                            case 'key': return [3 /*break*/, 31];
                            case 'message': return [3 /*break*/, 32];
                            case 'namespace-alias': return [3 /*break*/, 33];
                            case 'number': return [3 /*break*/, 34];
                            case 'otherwise': return [3 /*break*/, 35];
                            case 'output': return [3 /*break*/, 36];
                            case 'param': return [3 /*break*/, 37];
                            case 'preserve-space': return [3 /*break*/, 39];
                            case 'processing-instruction': return [3 /*break*/, 40];
                            case 'sort': return [3 /*break*/, 41];
                            case 'strip-space': return [3 /*break*/, 42];
                            case 'stylesheet': return [3 /*break*/, 43];
                            case 'transform': return [3 /*break*/, 43];
                            case 'template': return [3 /*break*/, 45];
                            case 'text': return [3 /*break*/, 47];
                            case 'value-of': return [3 /*break*/, 48];
                            case 'variable': return [3 /*break*/, 49];
                            case 'when': return [3 /*break*/, 51];
                            case 'with-param': return [3 /*break*/, 52];
                        }
                        return [3 /*break*/, 53];
                    case 3: throw new Error("not implemented: ".concat(template.localName));
                    case 4: return [4 /*yield*/, this.xsltApplyTemplates(context, template, output)];
                    case 5:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 6: return [4 /*yield*/, this.xsltAttribute(context, template, output)];
                    case 7:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 8: throw new Error("not implemented: ".concat(template.localName));
                    case 9: return [4 /*yield*/, this.xsltCallTemplate(context, template, output)];
                    case 10:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 11: return [4 /*yield*/, this.xsltChoose(context, template, output)];
                    case 12:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 13: return [4 /*yield*/, this.xsltComment(context, template, output)];
                    case 14:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 15:
                        destinationCopyNode = output || context.outputNodeList[context.outputPosition];
                        node = this.xsltCopy(destinationCopyNode, context.nodeList[context.position]);
                        if (!node) return [3 /*break*/, 17];
                        return [4 /*yield*/, this.xsltChildNodes(context, template, node)];
                    case 16:
                        _b.sent();
                        _b.label = 17;
                    case 17: return [3 /*break*/, 54];
                    case 18:
                        select = (0, dom_1.xmlGetAttribute)(template, 'select');
                        value = this.xPath.xPathEval(select, context);
                        destinationNode = context.outputNodeList[context.outputPosition] || output;
                        if (value.type === 'node-set') {
                            nodes = value.nodeSetValue();
                            for (i = 0; i < nodes.length; ++i) {
                                this.xsltCopyOf(destinationNode, nodes[i]);
                            }
                        }
                        else {
                            node_1 = (0, dom_1.domCreateTextNode)(this.outputDocument, value.stringValue());
                            (0, dom_1.domAppendChild)(destinationNode, node_1);
                        }
                        return [3 /*break*/, 54];
                    case 19:
                        this.xsltDecimalFormat(context, template);
                        return [3 /*break*/, 54];
                    case 20: return [4 /*yield*/, this.xsltElement(context, template)];
                    case 21:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 22: throw new Error("not implemented: ".concat(template.localName));
                    case 23: return [4 /*yield*/, this.xsltForEach(context, template, output)];
                    case 24:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 25: return [4 /*yield*/, this.xsltIf(context, template, output)];
                    case 26:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 27: return [4 /*yield*/, this.xsltImport(context, template, output)];
                    case 28:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 29: return [4 /*yield*/, this.xsltInclude(context, template, output)];
                    case 30:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 31:
                        this.xsltKey(context, template);
                        return [3 /*break*/, 54];
                    case 32: throw new Error("not implemented: ".concat(template.localName));
                    case 33: throw new Error("not implemented: ".concat(template.localName));
                    case 34: throw new Error("not implemented: ".concat(template.localName));
                    case 35: throw new Error("xsl:otherwise can't be used outside of xsl:choose.");
                    case 36:
                        this.outputMethod = (0, dom_1.xmlGetAttribute)(template, 'method');
                        this.outputOmitXmlDeclaration = (0, dom_1.xmlGetAttribute)(template, 'omit-xml-declaration');
                        return [3 /*break*/, 54];
                    case 37: return [4 /*yield*/, this.xsltVariable(context, template, false)];
                    case 38:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 39: throw new Error("not implemented: ".concat(template.localName));
                    case 40: throw new Error("not implemented: ".concat(template.localName));
                    case 41:
                        this.xsltSort(context, template);
                        return [3 /*break*/, 54];
                    case 42: throw new Error("not implemented: ".concat(template.localName));
                    case 43: return [4 /*yield*/, this.xsltTransformOrStylesheet(context, template, output)];
                    case 44:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 45: return [4 /*yield*/, this.xsltTemplate(context, template, output)];
                    case 46:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 47:
                        this.xsltText(context, template, output);
                        return [3 /*break*/, 54];
                    case 48:
                        this.xsltValueOf(context, template, output);
                        return [3 /*break*/, 54];
                    case 49: return [4 /*yield*/, this.xsltVariable(context, template, true)];
                    case 50:
                        _b.sent();
                        return [3 /*break*/, 54];
                    case 51: throw new Error("xsl:when can't be used outside of xsl:choose.");
                    case 52: throw new Error("error if here: ".concat(template.localName));
                    case 53: throw new Error("error if here: ".concat(template.localName));
                    case 54: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `xsl:apply-templates`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output. Only used if there's no corresponding output node already defined.
     * @protected
     */
    Xslt.prototype.xsltApplyTemplates = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var getAllTemplates, select, nodes, mode, top, templates, modifiedContext, i, j, textNodeContext, clonedContext;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        getAllTemplates = function (top, template, mode) {
                            var templates = [];
                            for (var _i = 0, _a = top.childNodes.filter(function (c) { return c.nodeType == constants_1.DOM_ELEMENT_NODE && _this.isXsltElement(c, 'template'); }); _i < _a.length; _i++) {
                                var element = _a[_i];
                                // TODO: Remember why this logic was here.
                                // In the past the idea was to avoid executing the same matcher repeatedly,
                                // but this proved to be a *terrible* idea some time later.
                                // Will keep this code for a few more versions, then remove it.
                                /* const templateAncestor = template.getAncestorByLocalName('template');
                                if (templateAncestor === undefined) {
                                    continue;
                                }
                
                                if (templateAncestor.id === element.id) {
                                    continue;
                                } */
                                if (!mode || element.getAttributeValue('mode') === mode) {
                                    templates.push(element);
                                }
                            }
                            return templates;
                        };
                        select = (0, dom_1.xmlGetAttribute)(template, 'select');
                        nodes = [];
                        if (select) {
                            nodes = this.xPath.xPathEval(select, context).nodeSetValue();
                        }
                        else {
                            nodes = context.nodeList[context.position].childNodes;
                        }
                        mode = (0, dom_1.xmlGetAttribute)(template, 'mode');
                        top = template.ownerDocument.documentElement;
                        templates = getAllTemplates(top, template, mode);
                        modifiedContext = context.clone(nodes);
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < templates.length)) return [3 /*break*/, 7];
                        j = 0;
                        _a.label = 2;
                    case 2:
                        if (!(j < modifiedContext.contextSize())) return [3 /*break*/, 6];
                        if (!(modifiedContext.nodeList[j].nodeType === constants_1.DOM_TEXT_NODE)) return [3 /*break*/, 3];
                        textNodeContext = context.clone([modifiedContext.nodeList[j]], undefined, 0, undefined);
                        // TODO: verify if it is okay to pass the own text node as template.
                        this.commonLogicTextNode(textNodeContext, modifiedContext.nodeList[j], output);
                        return [3 /*break*/, 5];
                    case 3:
                        clonedContext = modifiedContext.clone([modifiedContext.nodeList[j]], undefined, 0, undefined);
                        clonedContext.inApplyTemplates = true;
                        // The output depth should be restarted, since
                        // another template is being applied from this point.
                        clonedContext.outputDepth = 0;
                        return [4 /*yield*/, this.xsltProcessContext(clonedContext, templates[i], output)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        ++j;
                        return [3 /*break*/, 2];
                    case 6:
                        ++i;
                        return [3 /*break*/, 1];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `xsl:attribute`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output. Only used if there's no corresponding output node already defined.
     * @protected
     */
    Xslt.prototype.xsltAttribute = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var nameExpr, name, documentFragment, value, sourceNode, parentSourceNode, outputNode, sourceRootNode, newRootNode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nameExpr = (0, dom_1.xmlGetAttribute)(template, 'name');
                        name = this.xsltAttributeValue(nameExpr, context);
                        documentFragment = (0, dom_1.domCreateDocumentFragment)(this.outputDocument);
                        return [4 /*yield*/, this.xsltChildNodes(context, template, documentFragment)];
                    case 1:
                        _a.sent();
                        value = (0, dom_1.xmlValueLegacyBehavior)(documentFragment);
                        if (output && output.nodeType === constants_1.DOM_DOCUMENT_FRAGMENT_NODE) {
                            (0, dom_1.domSetTransformedAttribute)(output, name, value);
                        }
                        else {
                            sourceNode = context.nodeList[context.position];
                            parentSourceNode = sourceNode.parentNode;
                            outputNode = sourceNode.outputNode;
                            // At this point, the output node should exist.
                            // If not, a new node is created.
                            if (outputNode === null || outputNode === undefined) {
                                outputNode = new dom_1.XNode(sourceNode.nodeType, sourceNode.nodeName, sourceNode.nodeValue, context.outputNodeList[context.outputPosition], sourceNode.namespaceUri);
                                sourceNode.outputNode = outputNode;
                            }
                            // Corner case:
                            // It can happen here that we don't have the root node set.
                            // In this case we need to append a copy of the root
                            // source node to receive the attribute.
                            if (outputNode.localName === '#document') {
                                sourceRootNode = context.root.childNodes[0];
                                newRootNode = (0, dom_1.domCreateElement)(this.outputDocument, sourceRootNode.nodeName);
                                newRootNode.transformedNodeName = sourceRootNode.nodeName;
                                newRootNode.transformedLocalName = sourceRootNode.localName;
                                (0, dom_1.domAppendTransformedChild)(outputNode, newRootNode);
                                outputNode = newRootNode;
                                parentSourceNode = newRootNode;
                            }
                            // If the parent transformation is something like `xsl:element`, we should
                            // add a copy of the attribute to this element.
                            (0, dom_1.domSetTransformedAttribute)(outputNode, name, value);
                            if (sourceNode.nodeType === constants_1.DOM_ATTRIBUTE_NODE) {
                                sourceNode.transformedNodeType = constants_1.DOM_ATTRIBUTE_NODE;
                                sourceNode.transformedNodeName = name;
                                sourceNode.transformedNodeValue = value;
                            }
                            // Some operations start by the tag attributes, and not by the tag itself.
                            // When this is the case, the output node is not set yet, so
                            // we add the transformed attributes into the original tag.
                            if (parentSourceNode && parentSourceNode.outputNode) {
                                (0, dom_1.domSetTransformedAttribute)(parentSourceNode.outputNode, name, value);
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `xsl:call-template`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output, used when a fragment is passed by a previous step.
     */
    Xslt.prototype.xsltCallTemplate = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var name, top, paramContext, i, childNode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        name = (0, dom_1.xmlGetAttribute)(template, 'name');
                        top = template.ownerDocument.documentElement;
                        paramContext = context.clone();
                        return [4 /*yield*/, this.xsltWithParam(paramContext, template)];
                    case 1:
                        _a.sent();
                        i = 0;
                        _a.label = 2;
                    case 2:
                        if (!(i < top.childNodes.length)) return [3 /*break*/, 5];
                        childNode = top.childNodes[i];
                        if (!(childNode.nodeType === constants_1.DOM_ELEMENT_NODE &&
                            this.isXsltElement(childNode, 'template') &&
                            (0, dom_1.domGetAttributeValue)(childNode, 'name') === name)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.xsltChildNodes(paramContext, childNode, output)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        ++i;
                        return [3 /*break*/, 2];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `xsl:choose`, its child nodes `xsl:when`, and
     * `xsl:otherwise`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output. Only used if there's no corresponding output node already defined.
     */
    Xslt.prototype.xsltChoose = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, childNode, test_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _i = 0, _a = template.childNodes;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 7];
                        childNode = _a[_i];
                        if (childNode.nodeType !== constants_1.DOM_ELEMENT_NODE) {
                            return [3 /*break*/, 6];
                        }
                        if (!this.isXsltElement(childNode, 'when')) return [3 /*break*/, 4];
                        test_1 = (0, dom_1.xmlGetAttribute)(childNode, 'test');
                        if (!this.xPath.xPathEval(test_1, context).booleanValue()) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.xsltChildNodes(context, childNode, output)];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 7];
                    case 3: return [3 /*break*/, 6];
                    case 4:
                        if (!this.isXsltElement(childNode, 'otherwise')) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.xsltChildNodes(context, childNode, output)];
                    case 5:
                        _b.sent();
                        return [3 /*break*/, 7];
                    case 6:
                        _i++;
                        return [3 /*break*/, 1];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `xsl:copy` for all node types.
     * @param {XNode} destination the node being copied to, part of output document.
     * @param {XNode} source the node being copied, part in input document.
     * @returns {XNode|null} If an element node was created, the element node. Otherwise, null.
     */
    Xslt.prototype.xsltCopy = function (destination, source) {
        if (source.nodeType == constants_1.DOM_ELEMENT_NODE) {
            var node = (0, dom_1.domCreateElement)(this.outputDocument, source.nodeName);
            node.transformedNodeName = source.nodeName;
            if (source.namespaceUri !== null && source.namespaceUri !== undefined) {
                (0, dom_1.domSetTransformedAttribute)(node, 'xmlns', source.namespaceUri);
            }
            (0, dom_1.domAppendTransformedChild)(destination, node);
            return node;
        }
        if (source.nodeType == constants_1.DOM_TEXT_NODE) {
            var node = (0, dom_1.domCreateTransformedTextNode)(this.outputDocument, source.nodeValue);
            (0, dom_1.domAppendTransformedChild)(destination, node);
        }
        else if (source.nodeType == constants_1.DOM_CDATA_SECTION_NODE) {
            var node = (0, dom_1.domCreateCDATASection)(this.outputDocument, source.nodeValue);
            (0, dom_1.domAppendTransformedChild)(destination, node);
        }
        else if (source.nodeType == constants_1.DOM_COMMENT_NODE) {
            var node = (0, dom_1.domCreateComment)(this.outputDocument, source.nodeValue);
            (0, dom_1.domAppendTransformedChild)(destination, node);
        }
        else if (source.nodeType == constants_1.DOM_ATTRIBUTE_NODE) {
            (0, dom_1.domSetTransformedAttribute)(destination, source.nodeName, source.nodeValue);
        }
        return null;
    };
    /**
     * Implements `xsl:comment`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output. Only used if there's no corresponding output node already defined.
     */
    Xslt.prototype.xsltComment = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var node, commentData, commentNode, resolvedOutput;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        node = (0, dom_1.domCreateDocumentFragment)(this.outputDocument);
                        return [4 /*yield*/, this.xsltChildNodes(context, template, node)];
                    case 1:
                        _a.sent();
                        commentData = (0, dom_1.xmlValue)(node);
                        commentNode = (0, dom_1.domCreateComment)(this.outputDocument, commentData);
                        resolvedOutput = output || context.outputNodeList[context.outputPosition];
                        resolvedOutput.appendChild(commentNode);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `xsl:copy-of` for node-set values of the select
     * expression. Recurses down the source node tree, which is part of
     * the input document.
     * @param {XNode} destination the node being copied to, part of output document.
     * @param {XNode} source the node being copied, part in input document.
     */
    Xslt.prototype.xsltCopyOf = function (destination, source) {
        if (source.nodeType == constants_1.DOM_DOCUMENT_FRAGMENT_NODE || source.nodeType == constants_1.DOM_DOCUMENT_NODE) {
            for (var i = 0; i < source.childNodes.length; ++i) {
                this.xsltCopyOf(destination, source.childNodes[i]);
            }
        }
        else {
            var node = this.xsltCopy(destination, source);
            if (node) {
                for (var i = 0; i < source.childNodes.length; ++i) {
                    this.xsltCopyOf(node, source.childNodes[i]);
                }
            }
        }
    };
    /**
     * Implements `xsl:decimal-format`, registering the settings in this instance
     * and the current context.
     * @param context The Expression Context.
     * @param template The template.
     */
    Xslt.prototype.xsltDecimalFormat = function (context, template) {
        var name = (0, dom_1.xmlGetAttribute)(template, 'name');
        var decimalSeparator = (0, dom_1.xmlGetAttribute)(template, 'decimal-separator');
        var groupingSeparator = (0, dom_1.xmlGetAttribute)(template, 'grouping-separator');
        var infinity = (0, dom_1.xmlGetAttribute)(template, 'infinity');
        var minusSign = (0, dom_1.xmlGetAttribute)(template, 'minus-sign');
        var naN = (0, dom_1.xmlGetAttribute)(template, 'NaN');
        var percent = (0, dom_1.xmlGetAttribute)(template, 'percent');
        var perMille = (0, dom_1.xmlGetAttribute)(template, 'per-mille');
        var zeroDigit = (0, dom_1.xmlGetAttribute)(template, 'zero-digit');
        var digit = (0, dom_1.xmlGetAttribute)(template, 'digit');
        var patternSeparator = (0, dom_1.xmlGetAttribute)(template, 'pattern-separator');
        this.decimalFormatSettings = {
            name: name || this.decimalFormatSettings.name,
            decimalSeparator: decimalSeparator || this.decimalFormatSettings.decimalSeparator,
            groupingSeparator: groupingSeparator || this.decimalFormatSettings.groupingSeparator,
            infinity: infinity || this.decimalFormatSettings.infinity,
            minusSign: minusSign || this.decimalFormatSettings.minusSign,
            naN: naN || this.decimalFormatSettings.naN,
            percent: percent || this.decimalFormatSettings.percent,
            perMille: perMille || this.decimalFormatSettings.perMille,
            zeroDigit: zeroDigit || this.decimalFormatSettings.zeroDigit,
            digit: digit || this.decimalFormatSettings.digit,
            patternSeparator: patternSeparator || this.decimalFormatSettings.patternSeparator
        };
        context.decimalFormatSettings = this.decimalFormatSettings;
    };
    /**
     * Implements `xsl:element`.
     * @param context The Expression Context.
     * @param template The template.
     */
    Xslt.prototype.xsltElement = function (context, template) {
        return __awaiter(this, void 0, void 0, function () {
            var nameExpr, name, node, clonedContext;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nameExpr = (0, dom_1.xmlGetAttribute)(template, 'name');
                        name = this.xsltAttributeValue(nameExpr, context);
                        node = (0, dom_1.domCreateElement)(this.outputDocument, name);
                        node.transformedNodeName = name;
                        (0, dom_1.domAppendTransformedChild)(context.outputNodeList[context.outputPosition], node);
                        // The element becomes the output node of the source node.
                        context.nodeList[context.position].outputNode = node;
                        clonedContext = context.clone(undefined, [node], undefined, 0);
                        return [4 /*yield*/, this.xsltChildNodes(clonedContext, template)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `xsl:for-each`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    Xslt.prototype.xsltForEach = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var select, nodes, sortContext, nodesWithParent, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        select = (0, dom_1.xmlGetAttribute)(template, 'select');
                        nodes = this.xPath.xPathEval(select, context).nodeSetValue();
                        if (nodes.length === 0) {
                            return [2 /*return*/];
                        }
                        sortContext = context.clone(nodes);
                        this.xsltSort(sortContext, template);
                        nodesWithParent = sortContext.nodeList.filter(function (n) { return n.parentNode !== null && n.parentNode !== undefined; });
                        if (nodesWithParent.length <= 0) {
                            throw new Error('Nodes with no parents defined.');
                        }
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < sortContext.contextSize())) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.xsltChildNodes(sortContext.clone(sortContext.nodeList, undefined, i), template, output)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        ++i;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `xsl:if`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    Xslt.prototype.xsltIf = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var test;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        test = (0, dom_1.xmlGetAttribute)(template, 'test');
                        if (!this.xPath.xPathEval(test, context).booleanValue()) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.xsltChildNodes(context, template, output)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `<xsl:import>`. For now the code is nearly identical to `<xsl:include>`, but there's
     * no precedence evaluation implemented yet.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    Xslt.prototype.xsltImport = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, major, minor, patch, hrefAttributeFind, hrefAttribute, fetchTest, fetchResponse, includedXslt;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = process.versions.node.split('.').map(Number), major = _a[0], minor = _a[1], patch = _a[2];
                        if (major <= 17 && minor < 5) {
                            throw new Error('Your Node.js version does not support `<xsl:import>`. If possible, please update your Node.js version to at least version 17.5.0.');
                        }
                        if (this.firstTemplateRan) {
                            throw new Error('<xsl:import> should be the first child node of <xsl:stylesheet> or <xsl:transform>.');
                        }
                        // We need to test here whether `window.fetch` is available or not.
                        // If it is a browser environemnt, it should be.
                        // Otherwise, we will need to import an equivalent library, like 'node-fetch'.
                        if (!global.globalThis.fetch) {
                            global.globalThis.fetch = fetch;
                            global.globalThis.Headers = Headers;
                            global.globalThis.Request = Request;
                            global.globalThis.Response = Response;
                        }
                        hrefAttributeFind = template.childNodes.filter(function (n) { return n.nodeName === 'href'; });
                        if (hrefAttributeFind.length <= 0) {
                            throw new Error('<xsl:import> with no href attribute defined.');
                        }
                        hrefAttribute = hrefAttributeFind[0];
                        return [4 /*yield*/, global.globalThis.fetch(hrefAttribute.nodeValue)];
                    case 1:
                        fetchTest = _b.sent();
                        return [4 /*yield*/, fetchTest.text()];
                    case 2:
                        fetchResponse = _b.sent();
                        includedXslt = this.xmlParser.xmlParse(fetchResponse);
                        return [4 /*yield*/, this.xsltChildNodes(context, includedXslt.childNodes[0], output)];
                    case 3:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `xsl:include`.
     * @param context The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    Xslt.prototype.xsltInclude = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, major, minor, patch, hrefAttributeFind, hrefAttribute, fetchTest, fetchResponse, includedXslt;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = process.versions.node.split('.').map(Number), major = _a[0], minor = _a[1], patch = _a[2];
                        if (major <= 17 && minor < 5) {
                            throw new Error('Your Node.js version does not support `<xsl:include>`. If possible, please update your Node.js version to at least version 17.5.0.');
                        }
                        // We need to test here whether `window.fetch` is available or not.
                        // If it is a browser environemnt, it should be.
                        // Otherwise, we will need to import an equivalent library, like 'node-fetch'.
                        if (!global.globalThis.fetch) {
                            global.globalThis.fetch = fetch;
                            global.globalThis.Headers = Headers;
                            global.globalThis.Request = Request;
                            global.globalThis.Response = Response;
                        }
                        hrefAttributeFind = template.childNodes.filter(function (n) { return n.nodeName === 'href'; });
                        if (hrefAttributeFind.length <= 0) {
                            throw new Error('<xsl:include> with no href attribute defined.');
                        }
                        hrefAttribute = hrefAttributeFind[0];
                        return [4 /*yield*/, global.globalThis.fetch(hrefAttribute.nodeValue)];
                    case 1:
                        fetchTest = _b.sent();
                        return [4 /*yield*/, fetchTest.text()];
                    case 2:
                        fetchResponse = _b.sent();
                        includedXslt = this.xmlParser.xmlParse(fetchResponse);
                        return [4 /*yield*/, this.xsltChildNodes(context, includedXslt.childNodes[0], output)];
                    case 3:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Implements `xsl:key`.
     * @param context The Expression Context.
     * @param template The template.
     */
    Xslt.prototype.xsltKey = function (context, template) {
        // `name`, `match`, and `use` are required.
        var name = (0, dom_1.xmlGetAttribute)(template, 'name');
        var match = (0, dom_1.xmlGetAttribute)(template, 'match');
        var use = (0, dom_1.xmlGetAttribute)(template, 'use');
        if (!name || !match || !use) {
            var errorMessage = '<xsl:key> missing required parameters: ';
            if (!name) {
                errorMessage += 'name, ';
            }
            if (!match) {
                errorMessage += 'match, ';
            }
            if (!use) {
                errorMessage += 'use, ';
            }
            errorMessage = errorMessage.slice(0, -2);
            throw new Error(errorMessage);
        }
        var keyContext;
        if (context.nodeList[context.position].nodeName === '#document') {
            keyContext = context.clone(context.nodeList[context.position].childNodes);
        }
        else {
            keyContext = context;
        }
        var nodes = this.xsltMatch(match, keyContext);
        if (!(name in context.keys)) {
            context.keys[name] = {};
        }
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var node = nodes_1[_i];
            var nodeContext = context.clone([node]);
            var attribute = this.xPath.xPathEval(use, nodeContext);
            var attributeValue = attribute.stringValue();
            context.keys[name][attributeValue] = new values_1.NodeSetValue([node]);
        }
    };
    /**
     * Orders the current node list in the input context according to the
     * sort order specified by xsl:sort child nodes of the current
     * template node. This happens before the operation specified by the
     * current template node is executed.
     * @param context The expression context.
     * @param template The template node.
     * @todo case-order is not implemented.
     */
    Xslt.prototype.xsltSort = function (context, template) {
        var sort = [];
        for (var _i = 0, _a = template.childNodes; _i < _a.length; _i++) {
            var childNode = _a[_i];
            if (childNode.nodeType == constants_1.DOM_ELEMENT_NODE && this.isXsltElement(childNode, 'sort')) {
                var select = (0, dom_1.xmlGetAttribute)(childNode, 'select');
                var expression = this.xPath.xPathParse(select);
                var type = (0, dom_1.xmlGetAttribute)(childNode, 'data-type') || 'text';
                var order = (0, dom_1.xmlGetAttribute)(childNode, 'order') || 'ascending';
                sort.push({
                    expr: expression,
                    type: type,
                    order: order
                });
            }
        }
        this.xPath.xPathSort(context, sort);
    };
    /**
     * Implements `xsl:template`.
     * @param context The Expression Context.
     * @param template The `<xsl:template>` node.
     * @param output The output. In general, a fragment that will be used by
     *               the caller.
     */
    Xslt.prototype.xsltTemplate = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var match, nodes, templateContext;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // If `<xsl:template>` is executed outside `<xsl:apply-templates>`,
                        // only one match is accepted per level (or per context here).
                        if (!context.inApplyTemplates && context.baseTemplateMatched) {
                            return [2 /*return*/];
                        }
                        match = (0, dom_1.xmlGetAttribute)(template, 'match');
                        if (!match)
                            return [2 /*return*/];
                        nodes = this.xsltMatch(match, context, 'self-and-siblings');
                        if (!(nodes.length > 0)) return [3 /*break*/, 2];
                        this.firstTemplateRan = true;
                        if (!context.inApplyTemplates) {
                            context.baseTemplateMatched = true;
                        }
                        templateContext = context.clone(nodes, undefined, 0);
                        return [4 /*yield*/, this.xsltChildNodes(templateContext, template, output)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    Xslt.prototype.xsltText = function (context, template, output) {
        var text = (0, dom_1.xmlValue)(template);
        var node = (0, dom_1.domCreateTransformedTextNode)(this.outputDocument, text);
        var disableOutputEscaping = template.childNodes.filter(function (a) { return a.nodeType === constants_1.DOM_ATTRIBUTE_NODE && a.nodeName === 'disable-output-escaping'; });
        if (disableOutputEscaping.length > 0 && disableOutputEscaping[0].nodeValue === 'yes') {
            node.escape = false;
        }
        var destinationTextNode = output || context.outputNodeList[context.outputPosition];
        destinationTextNode.appendTransformedChild(node);
    };
    /**
     * Implements `<xsl:stylesheet>` and `<xsl:transform>`, and its corresponding
     * validations.
     * @param context The Expression Context.
     * @param template The `<xsl:stylesheet>` or `<xsl:transform>` node.
     * @param output The output. In general, a fragment that will be used by
     *               the caller.
     */
    Xslt.prototype.xsltTransformOrStylesheet = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, stylesheetAttribute;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        for (_i = 0, _a = template.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; }); _i < _a.length; _i++) {
                            stylesheetAttribute = _a[_i];
                            switch (stylesheetAttribute.nodeName) {
                                case 'version':
                                    this.version = stylesheetAttribute.nodeValue;
                                    if (!['1.0', '2.0', '3.0'].includes(this.version)) {
                                        throw new Error("XSLT version not defined or invalid. Actual resolved version: ".concat(this.version || '(none)', "."));
                                    }
                                    context.xsltVersion = this.version;
                                    break;
                                default:
                                    if (stylesheetAttribute.prefix === 'xmlns') {
                                        context.knownNamespaces[stylesheetAttribute.localName] = stylesheetAttribute.nodeValue;
                                    }
                                    break;
                            }
                        }
                        return [4 /*yield*/, this.xsltChildNodes(context, template, output)];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Xslt.prototype.xsltValueOf = function (context, template, output) {
        var select = (0, dom_1.xmlGetAttribute)(template, 'select');
        var attribute = this.xPath.xPathEval(select, context);
        var value = attribute.stringValue();
        var node = (0, dom_1.domCreateTransformedTextNode)(this.outputDocument, value);
        node.siblingPosition = context.nodeList[context.position].siblingPosition;
        if (output && output.nodeType === constants_1.DOM_DOCUMENT_FRAGMENT_NODE) {
            output.appendTransformedChild(node);
        }
        else {
            context.outputNodeList[context.outputPosition].appendTransformedChild(node);
        }
    };
    /**
     * Evaluates a variable or parameter and set it in the current input
     * context. Implements `xsl:variable`, `xsl:param`, and `xsl:with-param`.
     *
     * @param context The expression context.
     * @param template The template node.
     * @param override flag that defines if the value computed here
     * overrides the one already in the input context if that is the
     * case. I.e. decides if this is a default value or a local
     * value. `xsl:variable` and `xsl:with-param` override; `xsl:param` doesn't.
     */
    Xslt.prototype.xsltVariable = function (context, template, override) {
        return __awaiter(this, void 0, void 0, function () {
            var name, select, value, nonAttributeChildren, fragment, parameterValue, filteredParameter;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        name = (0, dom_1.xmlGetAttribute)(template, 'name');
                        select = (0, dom_1.xmlGetAttribute)(template, 'select');
                        nonAttributeChildren = template.childNodes.filter(function (n) { return n.nodeType !== constants_1.DOM_ATTRIBUTE_NODE; });
                        if (!(nonAttributeChildren.length > 0)) return [3 /*break*/, 2];
                        fragment = (0, dom_1.domCreateDocumentFragment)(template.ownerDocument);
                        return [4 /*yield*/, this.xsltChildNodes(context, template, fragment)];
                    case 1:
                        _a.sent();
                        value = new values_1.NodeSetValue([fragment]);
                        return [3 /*break*/, 3];
                    case 2:
                        if (select) {
                            value = this.xPath.xPathEval(select, context);
                        }
                        else {
                            parameterValue = '';
                            filteredParameter = this.options.parameters.filter(function (p) { return p.name === name; });
                            if (filteredParameter.length > 0) {
                                parameterValue = filteredParameter[0].value;
                            }
                            value = new values_1.StringValue(parameterValue);
                        }
                        _a.label = 3;
                    case 3:
                        if (override || !context.getVariable(name)) {
                            context.setVariable(name, value);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Traverses the template node tree. Calls the main processing
     * function with the current input context for every child node of the
     * current template node.
     * @param context Normally the Expression Context.
     * @param template The XSL-T definition.
     * @param output If set, the output where the transformation should occur.
     */
    Xslt.prototype.xsltChildNodes = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var contextClone, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contextClone = context.clone();
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < template.childNodes.length)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.xsltProcessContext(contextClone, template.childNodes[i], output)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        ++i;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This logic is used in two different places:
     * - `xsltPassThrough`, if the template asks this library to write a text node;
     * - `xsltProcessContext`, `apply-templates` operation, when the current node is text.
     *
     * Text nodes always require a parent, and they never have children.
     * @param context The Expression Context.
     * @param template The template, that contains the node value to be written.
     * @param output The output.
     */
    Xslt.prototype.commonLogicTextNode = function (context, template, output) {
        if (output && output.nodeType === constants_1.DOM_DOCUMENT_FRAGMENT_NODE) {
            var node = (0, dom_1.domCreateTransformedTextNode)(this.outputDocument, template.nodeValue);
            (0, dom_1.domAppendTransformedChild)(output, node);
        }
        else {
            var parentNode = context.outputNodeList[context.outputPosition];
            var textNodeList = parentNode.transformedChildNodes.filter(function (n) { return n.nodeType === constants_1.DOM_TEXT_NODE; });
            if (textNodeList.length > 0) {
                var node = textNodeList[0];
                node.transformedNodeValue = template.nodeValue;
            }
            else {
                var node = (0, dom_1.domCreateTransformedTextNode)(this.outputDocument, template.nodeValue);
                node.transformedParentNode = parentNode;
                // context.nodeList[context.position].outputNode = node;
                (0, dom_1.domAppendTransformedChild)(parentNode, node);
            }
        }
    };
    /**
     * Passes template text to the output. The current template node does
     * not specify an XSL-T operation and therefore is appended to the
     * output with all its attributes. Then continues traversing the
     * template node tree.
     * @param context The Expression Context.
     * @param template The XSLT stylesheet or transformation.
     * @param output The output.
     */
    Xslt.prototype.xsltPassThrough = function (context, template, output) {
        return __awaiter(this, void 0, void 0, function () {
            var node, elementContext, newNode, outputNode, clonedContext, transformedChildNodes, _i, transformedChildNodes_1, previouslyTransformedAttribute, name_1, value, transformedAttributes, _a, transformedAttributes_1, previouslyTransformedAttribute, name_2, value, templateAttributes, _b, templateAttributes_1, attribute, name_3, value;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(template.nodeType == constants_1.DOM_TEXT_NODE)) return [3 /*break*/, 1];
                        if (this.xsltPassText(template)) {
                            this.commonLogicTextNode(context, template, output);
                        }
                        return [3 /*break*/, 5];
                    case 1:
                        if (!(template.nodeType == constants_1.DOM_ELEMENT_NODE)) return [3 /*break*/, 3];
                        node = void 0;
                        elementContext = context;
                        if (context.nodeList[context.position].nodeName === '#document') {
                            node = context.nodeList[context.position].childNodes.find(function (c) { return c.nodeName !== '#dtd-section'; });
                            elementContext = context.clone([node]);
                        }
                        else {
                            node = context.nodeList[context.position];
                        }
                        newNode = void 0;
                        if (node.outputNode === undefined || node.outputNode === null || context.outputDepth > 0) {
                            newNode = (0, dom_1.domCreateElement)(this.outputDocument, template.nodeName);
                            newNode.siblingPosition = node.siblingPosition;
                            if (context.outputDepth === 0) {
                                node.outputNode = newNode;
                            }
                        }
                        else {
                            newNode = node.outputNode;
                        }
                        newNode.transformedNodeName = template.nodeName;
                        newNode.transformedLocalName = template.localName;
                        outputNode = context.outputNodeList[context.outputPosition];
                        (0, dom_1.domAppendTransformedChild)(outputNode, newNode);
                        clonedContext = elementContext.cloneByOutput(outputNode.transformedChildNodes, outputNode.transformedChildNodes.length - 1, ++elementContext.outputDepth);
                        return [4 /*yield*/, this.xsltChildNodes(clonedContext, template)];
                    case 2:
                        _c.sent();
                        transformedChildNodes = node.transformedChildNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE; });
                        for (_i = 0, transformedChildNodes_1 = transformedChildNodes; _i < transformedChildNodes_1.length; _i++) {
                            previouslyTransformedAttribute = transformedChildNodes_1[_i];
                            name_1 = previouslyTransformedAttribute.transformedNodeName;
                            value = previouslyTransformedAttribute.transformedNodeValue;
                            (0, dom_1.domSetTransformedAttribute)(newNode, name_1, value);
                        }
                        transformedAttributes = node.childNodes.filter(function (n) { return n.nodeType === constants_1.DOM_ATTRIBUTE_NODE && n.transformedNodeName; });
                        for (_a = 0, transformedAttributes_1 = transformedAttributes; _a < transformedAttributes_1.length; _a++) {
                            previouslyTransformedAttribute = transformedAttributes_1[_a];
                            name_2 = previouslyTransformedAttribute.transformedNodeName;
                            value = previouslyTransformedAttribute.transformedNodeValue;
                            (0, dom_1.domSetTransformedAttribute)(newNode, name_2, value);
                        }
                        templateAttributes = template.childNodes.filter(function (a) { return (a === null || a === void 0 ? void 0 : a.nodeType) === constants_1.DOM_ATTRIBUTE_NODE; });
                        for (_b = 0, templateAttributes_1 = templateAttributes; _b < templateAttributes_1.length; _b++) {
                            attribute = templateAttributes_1[_b];
                            name_3 = attribute.nodeName;
                            value = this.xsltAttributeValue(attribute.nodeValue, elementContext);
                            (0, dom_1.domSetTransformedAttribute)(newNode, name_3, value);
                        }
                        return [3 /*break*/, 5];
                    case 3: 
                    // This applies also to the DOCUMENT_NODE of the XSL stylesheet,
                    // so we don't have to treat it specially.
                    return [4 /*yield*/, this.xsltChildNodes(context, template, output)];
                    case 4:
                        // This applies also to the DOCUMENT_NODE of the XSL stylesheet,
                        // so we don't have to treat it specially.
                        _c.sent();
                        _c.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Determines if a text node in the XSLT template document is to be
     * stripped according to XSLT whitespace stripping rules.
     * @see [XSLT], section 3.4.
     * @param template The XSLT template.
     * @returns TODO
     * @todo Whitespace stripping on the input document is
     * currently not implemented.
     */
    Xslt.prototype.xsltPassText = function (template) {
        if (!template.nodeValue.match(/^\s*$/)) {
            return true;
        }
        var element = template.parentNode;
        if (this.isXsltElement(element, 'text')) {
            return true;
        }
        while (element && element.nodeType == constants_1.DOM_ELEMENT_NODE) {
            var xmlspace = (0, dom_1.domGetAttributeValue)(element, 'xml:space');
            if (xmlspace) {
                if (xmlspace == 'default') {
                    return false;
                }
                if (xmlspace == 'preserve') {
                    return true;
                }
            }
            element = element.parentNode;
        }
        return false;
    };
    Xslt.prototype.findAttributeInContext = function (attributeName, context) {
        return context.nodeList[context.position].childNodes.find(function (a) { return a.nodeType === constants_1.DOM_ATTRIBUTE_NODE && a.nodeName === attributeName; });
    };
    /**
     * Evaluates an XSL-T attribute value template. Attribute value
     * templates are attributes on XSL-T elements that contain XPath
     * expressions in braces {}. The XSL-T expressions are evaluated in
     * the current input context.
     * @param value TODO
     * @param context TODO
     * @returns TODO
     */
    Xslt.prototype.xsltAttributeValue = function (value, context) {
        var parts = value.split('{');
        if (parts.length === 1) {
            return value;
        }
        var ret = '';
        for (var i = 0; i < parts.length; ++i) {
            var rp = parts[i].split('}');
            if (rp.length != 2) {
                // first literal part of the value
                ret += parts[i];
                continue;
            }
            var val = this.xPath.xPathEval(rp[0], context).stringValue();
            ret += val + rp[1];
        }
        return ret;
    };
    /**
     * Evaluates an XPath expression in the current input context as a
     * match.
     * @see [XSLT] section 5.2, paragraph 1
     * @param match TODO
     * @param context The Expression Context.
     * @param axis The XPath axis. Used when the match does not start with the parent.
     * @returns {XNode[]} A list of the found nodes.
     */
    Xslt.prototype.xsltMatch = function (match, context, axis) {
        var expression = this.xPath.xPathParse(match, axis);
        return this.matchResolver.expressionMatch(expression, context);
    };
    /**
     * Sets parameters defined by xsl:with-param child nodes of the
     * current template node, in the current input context. This happens
     * before the operation specified by the current template node is
     * executed.
     * @param context The Expression Context.
     * @param template The template node.
     */
    Xslt.prototype.xsltWithParam = function (context, template) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, childNode;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _i = 0, _a = template.childNodes;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        childNode = _a[_i];
                        if (!(childNode.nodeType === constants_1.DOM_ELEMENT_NODE && this.isXsltElement(childNode, 'with-param'))) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.xsltVariable(context, childNode, true)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    // Test if the given element is an XSLT element, optionally the one with the given name
    Xslt.prototype.isXsltElement = function (element, opt_wantedName) {
        if (opt_wantedName && element.localName != opt_wantedName)
            return false;
        if (element.namespaceUri)
            return element.namespaceUri === 'http://www.w3.org/1999/XSL/Transform';
        return element.prefix === 'xsl'; // backwards compatibility with earlier versions of xslt-processor
    };
    return Xslt;
}());
exports.Xslt = Xslt;
//# sourceMappingURL=xslt.js.map