import { XNode } from '../dom';
import { XsltDecimalFormatSettings } from '../xslt/xslt-decimal-format-settings';
import { NodeValue } from './values';
/**
 * XPath expression evaluation context. An XPath context consists of a
 * DOM node, a list of DOM nodes that contains this node, a number
 * that represents the position of the single node in the list, and a
 * current set of variable bindings. (See XPath spec.)
 *
 *   setVariable(name, expr) -- binds given XPath expression to the
 *   name.
 *
 *   getVariable(name) -- what the name says.
 *
 *   setNode(position) -- sets the context to the node at the given
 *   position. Needed to implement scoping rules for variables in
 *   XPath. (A variable is visible to all subsequent siblings, not
 *   only to its children.)
 *
 *   set/isCaseInsensitive -- specifies whether node name tests should
 *   be case sensitive.  If you're executing xpaths against a regular
 *   HTML DOM, you probably don't want case-sensitivity, because
 *   browsers tend to disagree about whether elements & attributes
 *   should be upper/lower case.  If you're running xpaths in an
 *   XSLT instance, you probably DO want case sensitivity, as per the
 *   XSL spec.
 *
 *   set/isReturnOnFirstMatch -- whether XPath evaluation should quit as soon
 *   as a result is found. This is an optimization that might make sense if you
 *   only care about the first result.
 *
 *   set/isIgnoreNonElementNodesForNTA -- whether to ignore non-element nodes
 *   when evaluating the "node()" any node test. While technically this is
 *   contrary to the XPath spec, practically it can enhance performance
 *   significantly, and makes sense if you a) use "node()" when you mean "*",
 *   and b) use "//" when you mean "/descendant::* /".
 */
export declare class ExprContext {
    position: number;
    nodeList: XNode[];
    outputPosition: number;
    outputNodeList: XNode[];
    outputDepth: number;
    xsltVersion: '1.0' | '2.0' | '3.0';
    variables: {
        [name: string]: NodeValue;
    };
    keys: {
        [name: string]: {
            [key: string]: NodeValue;
        };
    };
    knownNamespaces: {
        [alias: string]: string;
    };
    caseInsensitive: any;
    ignoreAttributesWithoutValue: any;
    returnOnFirstMatch: any;
    ignoreNonElementNodesForNTA: any;
    parent: ExprContext;
    root: XNode;
    decimalFormatSettings: XsltDecimalFormatSettings;
    inApplyTemplates: boolean;
    baseTemplateMatched: boolean;
    /**
     * Constructor -- gets the node, its position, the node set it
     * belongs to, and a parent context as arguments. The parent context
     * is used to implement scoping rules for variables: if a variable
     * is not found in the current context, it is looked for in the
     * parent context, recursively. Except for node, all arguments have
     * default values: default position is 0, default node set is the
     * set that contains only the node, and the default parent is null.
     *
     * Notice that position starts at 0 at the outside interface;
     * inside XPath expressions this shows up as position()=1.
     * @param nodeList TODO
     * @param outputNodeList TODO
     * @param opt_position TODO
     * @param opt_outputPosition TODO
     * @param opt_parent TODO
     * @param opt_caseInsensitive TODO
     * @param opt_ignoreAttributesWithoutValue TODO
     * @param opt_returnOnFirstMatch TODO
     * @param opt_ignoreNonElementNodesForNTA TODO
     */
    constructor(nodeList: XNode[], outputNodeList: XNode[], xsltVersion?: '1.0' | '2.0' | '3.0', opt_position?: number, opt_outputPosition?: number, opt_outputDepth?: number, opt_decimalFormatSettings?: XsltDecimalFormatSettings, opt_variables?: {
        [name: string]: any;
    }, opt_knownNamespaces?: {
        [alias: string]: string;
    }, opt_parent?: ExprContext, opt_caseInsensitive?: any, opt_ignoreAttributesWithoutValue?: any, opt_returnOnFirstMatch?: any, opt_ignoreNonElementNodesForNTA?: any);
    /**
     * clone() -- creates a new context with the current context as
     * parent. If passed as argument to clone(), the new context has a
     * different node, position, or node set. What is not passed is
     * inherited from the cloned context.
     * @param opt_nodeList TODO
     * @param opt_outputNodeList TODO
     * @param opt_position TODO
     * @param opt_outputPosition TODO
     * @returns TODO
     */
    clone(opt_nodeList?: XNode[], opt_outputNodeList?: XNode[], opt_position?: number, opt_outputPosition?: number): ExprContext;
    cloneByOutput(opt_outputNodeList?: XNode[], opt_outputPosition?: number, opt_outputDepth?: number): ExprContext;
    setVariable(name?: string, value?: NodeValue | string): void;
    getVariable(name: string): NodeValue;
    setNode(position: number): void;
    contextSize(): number;
    isCaseInsensitive(): any;
    setCaseInsensitive(caseInsensitive: any): any;
    isIgnoreAttributesWithoutValue(): any;
    setIgnoreAttributesWithoutValue(ignore: any): any;
    isReturnOnFirstMatch(): any;
    setReturnOnFirstMatch(returnOnFirstMatch: any): any;
    isIgnoreNonElementNodesForNTA(): any;
    setIgnoreNonElementNodesForNTA(ignoreNonElementNodesForNTA: any): any;
}
